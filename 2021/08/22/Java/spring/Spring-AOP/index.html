<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenpeng.pages.dev","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="面向切面编程 (AOP) 通过提供另一种思考程序结构的方式来补充面向对象编程 (OOP)。 OOP 中模块化的关键单位是类，而 AOP 中模块化的单位是切面。切面是能够实现跨越多种类型和对象的关注点（例如事务管理）的模块化。 （这种关注点在 AOP 文献中通常被称为“横切”关注点。）">
<meta property="og:type" content="article">
<meta property="og:title" content="spring-aop">
<meta property="og:url" content="https://chenpeng.pages.dev/2021/08/22/Java/spring/Spring-AOP/index.html">
<meta property="og:site_name" content="陈鹏的博客">
<meta property="og:description" content="面向切面编程 (AOP) 通过提供另一种思考程序结构的方式来补充面向对象编程 (OOP)。 OOP 中模块化的关键单位是类，而 AOP 中模块化的单位是切面。切面是能够实现跨越多种类型和对象的关注点（例如事务管理）的模块化。 （这种关注点在 AOP 文献中通常被称为“横切”关注点。）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenpeng.pages.dev/2021/08/22/Java/spring/Spring-AOP/aop-proxy-plain-pojo-call.png">
<meta property="og:image" content="https://chenpeng.pages.dev/2021/08/22/Java/spring/Spring-AOP/aop-proxy-call.png">
<meta property="article:published_time" content="2021-08-22T05:48:33.000Z">
<meta property="article:modified_time" content="2022-04-14T04:23:46.646Z">
<meta property="article:author" content="CHENPENGBLOG">
<meta property="article:tag" content="java">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenpeng.pages.dev/2021/08/22/Java/spring/Spring-AOP/aop-proxy-plain-pojo-call.png">

<link rel="canonical" href="https://chenpeng.pages.dev/2021/08/22/Java/spring/Spring-AOP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>spring-aop | 陈鹏的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">陈鹏的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">每天进步一点点😉</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenpeng.pages.dev/2021/08/22/Java/spring/Spring-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CHENPENGBLOG">
      <meta itemprop="description" content="全栈搞起来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈鹏的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spring-aop
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-22 13:48:33" itemprop="dateCreated datePublished" datetime="2021-08-22T13:48:33+08:00">2021-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 12:23:46" itemprop="dateModified" datetime="2022-04-14T12:23:46+08:00">2022-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面向切面编程 (AOP) 通过提供另一种思考程序结构的方式来补充面向对象编程 (OOP)。 OOP 中模块化的关键单位是类，而 AOP 中模块化的单位是切面。切面是能够实现跨越多种类型和对象的关注点（例如事务管理）的模块化。 （这种关注点在 AOP 文献中通常被称为“横切”关注点。）</p>
<span id="more"></span>

<p>Spring 通过使用<code>schema-based approach</code>或 <code>@AspectJ annotation style</code>, 提供编写自定义切面的简单而强大的方法。</p>
<p>AOP 在 Spring 框架中用于：</p>
<ul>
<li>提供声明式企业服务。最重要是声明式事务管理。</li>
<li>让用户实现自定义切面，用 AOP 补充他们对 OOP 的使用。</li>
</ul>
<h2 id="AOP-概念"><a href="#AOP-概念" class="headerlink" title="AOP 概念"></a>AOP 概念</h2><p>AOP 术语：</p>
<ul>
<li>切面 <code>aspect</code>：横切关注点的模块化。事务管理是企业 Java 应用程序中常见的横切关注点。在 Spring AOP 中，切面通过使用常规类(<code>schema-based approach</code>)或使用<code>@Aspect</code>注解(<code>@AspectJ</code> style)注解 的常规类来实现的。</li>
<li>连接点<code> Join point</code>：在程序执行过程中的一点，例如方法的执行或异常的处理。在 Spring AOP 中，连接点始终代表方法的执行。</li>
<li>通知 <code>Advice</code>：切面在特定的连接点处采取的操作。通知的类型包括“around”、“before”和“after”通知。许多 AOP 框架，包括 Spring，将通知建模为拦截器，并在连接点周围维护一个拦截器链。</li>
<li>切入点 <code>Pointcut</code>：匹配连接点的谓词。 <code>Advice </code>与<code>Pointcut</code>表达式相关联，并在与切入点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。由切入点表达式匹配的连接点的概念是 AOP 的核心，Spring 默认使用 AspectJ 切入点表达式语言。</li>
<li>简介<code>Introduction</code>：代表类型声明其他方法或字段。 Spring AOP 允许您向任何建议的对象引入新的接口(和相应的实现)。例如，可以使用<code>Introduction</code>使 Bean 实现<code>IsModified</code>接口，以简化缓存。</li>
<li>目标对象 <code>Target object</code>：一个或多个切面通知的对象，也称为“通知对象”。由于 Spring AOP 是使用运行时代理实现的，因此该对象始终是代理对象。</li>
<li>AOP 代理 <code>AOP proxy</code>：由 AOP 框架为实现切面协定所创建的对象(通知方法执行等)。在 Spring Framework 中，AOP 代理是 JDK 动态代理或 CGLIB 代理。</li>
<li>编织 <code>Weaving</code>： linking aspects with other application types or objects to create an advised object. 这可以在编译时(例如，使用 AspectJ 编译器)，加载时或在运行时完成。Spring AOP 在运行时执行编织。</li>
</ul>
<p>Spring AOP 包括以下类型的通知：</p>
<ul>
<li>Before advice：在连接点之前运行的通知，但是它不能阻止执行流程前进到连接点(除非它引发异常)。</li>
<li>After returning advice：在连接点正常完成后要运行的通知(例如，如果方法返回而没有引发异常)。</li>
<li>After throwing advice：如果方法因抛出异常而退出，则执行建议。</li>
<li>after (finally) advice：无论连接点退出的方式如何(正常或特殊返回)，均应执行建议。</li>
<li>Around advice：环绕连接点的通知，例如方法调用。这是最有力的建议。This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or throwing an exception.</li>
</ul>
<p>Around advice is the most general kind of advice. Since Spring AOP, like AspectJ, provides a full range of advice types, we recommend that you use the least powerful advice type that can implement the required behavior. For example, if you need only to update a cache with the return value of a method, you are better off implementing an after returning advice than an around advice, although an around advice can accomplish the same thing. Using the most specific advice type provides a simpler programming model with less potential for errors. For example, you do not need to invoke the <code>proceed()</code> method on the <code>JoinPoint</code> used for around advice, and, hence, you cannot fail to invoke it.</p>
<p><code>pointcut </code>匹配 <code>joinpoint </code>概念是 AOP 的关键，它区别于仅提供拦截的旧技术。切入点使通知能够独立于面向对象的层次结构而成为目标。例如，可以将提供声明式事务管理的环绕通知应用于一组跨越多个对象的方法（例如服务层中的所有业务操作）。</p>
<h2 id="SpringAOP-能力和目标"><a href="#SpringAOP-能力和目标" class="headerlink" title="SpringAOP 能力和目标"></a>SpringAOP 能力和目标</h2><p>Spring AOP 是用纯 Java 实现的。不需要特殊的编译过程。 Spring AOP 不需要控制类加载器的层次结构，因此适合在 Servlet 容器或应用程序服务器中使用。</p>
<p>Spring AOP 当前仅支持方法执行连接点(建议在 Spring Bean 上执行方法)。</p>
<p>Spring AOP 的 AOP 方法目的不是提供最完整的 AOP 实现(尽管 Spring AOP 相当强大)。相反，其目的是在 AOP 实现和 Spring IoC 之间提供紧密的集成，以帮助解决企业应用程序中的常见问题。</p>
<p>因此，通常将 Spring Framework 的 AOP 功能与 Spring IoC 容器结合使用。通过使用常规 bean 定义语法来配置切面。这是与其他 AOP 实现的关键区别。</p>
<p>Spring AOP 从未努力与 AspectJ 竞争以提供全面的 AOP 解决方案。我们认为，基于代理的框架(如 Spring AOP)和成熟的框架(如 AspectJ)都是有价值的，它们是互补的，而不是竞争。 Spring 将 AspectsJ 无缝集成了 Spring AOP 和 IoC，以在基于 Spring 的一致应用程序架构中支持 AOP 的所有使用。这种集成不会影响 Spring AOP API 或 AOP Alliance API。</p>
<h2 id="AOP-代理"><a href="#AOP-代理" class="headerlink" title="AOP 代理"></a>AOP 代理</h2><p>Spring AOP 默认将标准 JDK 动态代理用于 AOP 代理。这使得可以代理任何接口(或一组接口)。</p>
<p>Spring AOP 也可以使用 CGLIB 代理。这对于代理类而不是接口是必需的。默认情况下，如果业务对象未实现接口，则使用 CGLIB。由于对接口而不是对类进行编程是一种好习惯，因此业务类通常实现一个或多个业务接口。在某些情况下(可能极少发生)，您需要通知未在接口上声明的方法，或者需要将代理对象作为具体类型传递给方法，则可以使用强制使用 CGLIB。</p>
<h2 id="AspectJ-支持"><a href="#AspectJ-支持" class="headerlink" title="@AspectJ 支持"></a>@AspectJ 支持</h2><p><code>@AspectJ</code> 是一种将切面声明为带有注解的常规 Java 类的样式。  Spring 使用 AspectJ 提供的用于切入点解析和匹配的库来解释与 AspectJ 5 相同的 注解。但是，AOP 运行时仍然是纯 Spring AOP，并且不依赖于 AspectJ 编译器或编织器。</p>
<h3 id="启用-AspectJ-支持"><a href="#启用-AspectJ-支持" class="headerlink" title="启用@AspectJ 支持"></a>启用@AspectJ 支持</h3><p>要在 Spring 配置中使用<code>@AspectJ</code> 切面，需要启用 Spring 支持以基于<code>@AspectJ</code> 切面配置 Spring AOP，并根据这些切面是否建议对它们进行自动代理。通过自动代理，我们的意思是，如果 Spring 确定一个或多个切面建议一个 bean，它会自动为该 bean 生成一个代理来拦截方法调用并确保按需执行建议。</p>
<p>可以使用 XML 或 Java 样式的配置来启用<code>@AspectJ </code>支持。无论哪种情况，都需要确保 AspectJ 的<code>aspectjweaver.jar</code>库位于应用程序的 <code>Classpath</code>(版本 1.8 或更高版本)上。该库在 <code>AspectJ </code>发行版的<code>lib</code>目录中或从 Maven Central 存储库中可用。</p>
<h4 id="通过-Java-配置启用-AspectJ-支持"><a href="#通过-Java-配置启用-AspectJ-支持" class="headerlink" title="通过 Java 配置启用@AspectJ 支持"></a>通过 Java 配置启用<code>@AspectJ</code> 支持</h4><p>要使用 Java <code>@Configuration</code>启用@AspectJ 支持，请添加<code>@EnableAspectJAutoProxy</code>注解，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxypublic</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-XML-配置启用-AspectJ-支持"><a href="#通过-XML-配置启用-AspectJ-支持" class="headerlink" title="通过 XML 配置启用@AspectJ 支持"></a>通过 XML 配置启用<code>@AspectJ</code> 支持</h4><p>要通过基于 XML 的配置启用<code>@AspectJ </code>支持，请使用<code>aop:aspectj-autoproxy</code>元素，如以下示例所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;aop:aspectj-autoproxy/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="声明一个切面"><a href="#声明一个切面" class="headerlink" title="声明一个切面"></a>声明一个切面</h3><p>启用<code>@AspectJ </code>支持后，Spring 会自动检测到在应用程序上下文中使用<code>@AspectJ </code>切面(具有<code>@Aspect</code>注解)的类定义的任何 bean，并用于配置 Spring AOP。</p>
<p>第一个示例显示了应用程序上下文中的常规 bean 定义，该定义指向具有<code>@Aspect</code>注解的 bean 类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.xyz.NotVeryUsefulAspect&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configure properties of the aspect here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二个示例显示了<code>NotVeryUsefulAspect</code>类定义，该类定义带有<code>org.aspectj.lang.annotation.Aspect</code>注解；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xyz;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>切面(带有<code>@Aspect</code>注解 的类)可以具有方法和字段，与任何其他类相同。它们还可以包含切入点，通知和引入(类型间)声明。</p>
<blockquote>
<p>通过扫描自动探测切面</p>
<p>可以将切面类注册为 Spring XML 配置中的常规 bean，也可以通过 Classpath 扫描来自动检测它们-与其他任何 Spring管理 的 bean 一样。但是，请注意，<code>@Aspect</code>注解不足以在 Classpath 中进行自动检测。为此，您需要添加一个单独的<code>@Component</code>注解(或者，按照 Spring 的组件扫描程序的规则，有条件的自定义构造型注解)。</p>
</blockquote>
<blockquote>
<p>使用切面对另一个切面进行通知?</p>
<p>在 Spring AOP 中，切面本身不能成为其他切面的通知目标。类上的<code>@Aspect</code>注解 将其标记为一个切面，因此将其从自动代理中排除。</p>
</blockquote>
<h3 id="声明切入点"><a href="#声明切入点" class="headerlink" title="声明切入点"></a>声明切入点</h3><p><code>pointcut</code>确定了感兴趣的<code>join point</code>，从而使我们能够控制执行通知的时间。 Spring AOP 仅支持 Spring Bean 的方法执行<code>join point</code>，因此可以将<code>pointcut</code>视为与 Spring Bean 上的方法执行相匹配。<code>pointcut</code>声明由两部分组成：一个包含名称和任何参数的签名，以及一个切入点表达式，该切入点表达式确定方法执行。在 AOP 的@AspectJ 注解样式中，常规方法定义提供了切入点签名。并通过使用<code>@Pointcut</code>注解 指示切入点表达式(用作切入点签名的方法必须具有<code>void</code>返回类型)。</p>
<p>下面的示例定义一个名为<code>anyOldTransfer</code>的切入点，该切入点与任何名为<code>transfer</code>的方法的执行相匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span> <span class="comment">// the pointcut expressionprivate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">// the pointcut signature</span></span><br></pre></td></tr></table></figure>

<p>形成<code>@Pointcut</code>注解的值的切入点表达式是一个常规的 AspectJ 5 切入点表达式。</p>
<h4 id="支持的切入点指示符"><a href="#支持的切入点指示符" class="headerlink" title="支持的切入点指示符"></a>支持的切入点指示符</h4><p>Spring AOP 支持以下在切入点表达式中使用的 AspectJ 切入点指示符(PCD)：</p>
<ul>
<li><code>execution</code>：用于匹配方法执行的连接点。这是使用 Spring AOP 时要使用的主要切入点指示符。</li>
<li><code>within</code>：将匹配限制为某些类型内的连接点(使用 Spring AOP 时，在匹配类型内声明的方法的执行)。</li>
<li><code>this</code>：将匹配限制为连接点(使用 Spring AOP 时方法的执行)，其中 bean 引用(Spring AOP 代理)是给定类型的实例。</li>
<li><code>target</code>：将目标对象(正在代理的应用程序对象)是给定类型的实例的连接点(使用 Spring AOP 时，方法的执行)限制为匹配。</li>
<li><code>args</code>：将参数限制为给定类型的实例的连接点(使用 Spring AOP 时方法的执行)限制匹配。</li>
<li><code>@target</code>：将执行对象的类具有给定类型的注解的连接点(使用 Spring AOP 时，方法的执行)限制为匹配。</li>
<li><code>@args</code>：限制匹配的连接点(使用 Spring AOP 时方法的执行)，其中传递的实际参数的运行时类型具有给定类型的 注解。</li>
<li><code>@within</code>：将匹配限制为具有给定注解的类型内的连接点(使用 Spring AOP 时，使用给定注解的类型中声明的方法的执行)。</li>
<li><code>@annotation</code>：将匹配限制为连接点的主题(在 Spring AOP 中正在执行的方法)具有给定注解的连接点。</li>
</ul>
<h4 id="组合切入点表达式"><a href="#组合切入点表达式" class="headerlink" title="组合切入点表达式"></a>组合切入点表达式</h4><p>您可以组合切入点表达式，可以使用<code>&amp;&amp;,</code> <code>||</code>和<code>!</code>进行组合。您也可以按名称引用切入点表达式。以下示例显示了三个切入点表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicOperation</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTrading</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tradingOperation</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>(1)</strong> <code>anyPublicOperation</code>匹配方法执行联接点是否表示任何公共方法的执行。</li>
<li><strong>(2)</strong> <code>inTrading</code>如果 Transaction 模块中有方法执行则匹配。</li>
<li><strong>(3)</strong> <code>tradingOperation</code>匹配，如果方法执行代表 Transaction 模块中的任何公共方法。</li>
</ul>
<p>最佳实践是从较小的命名组件中构建更复杂的切入点表达式，如先前所示。按名称引用切入点时，将应用常规的 Java 可见性规则(您可以看到相同类型的私有切入点，层次结构中受保护的切入点，任何位置的公共切入点，等等)。可见性不影响切入点匹配。</p>
<h4 id="共享通用切入点定义"><a href="#共享通用切入点定义" class="headerlink" title="共享通用切入点定义"></a>共享通用切入点定义</h4><p>在使用企业应用程序时，开发人员通常希望从多个切面引用应用程序的模块和特定的操作集。我们建议为此定义一个“ SystemArchitecture”切面，以捕获常见的切入点表达式。这样的切面通常类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.someapp;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A join point is in the web layer if the method is defined</span></span><br><span class="line"><span class="comment">    * in a type in the com.xyz.someapp.web package or any sub-package</span></span><br><span class="line"><span class="comment">    * under that.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inWebLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A join point is in the service layer if the method is defined</span></span><br><span class="line"><span class="comment">    * in a type in the com.xyz.someapp.service package or any sub-package</span></span><br><span class="line"><span class="comment">    * under that.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.service..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inServiceLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A join point is in the data access layer if the method is defined</span></span><br><span class="line"><span class="comment">    * in a type in the com.xyz.someapp.dao package or any sub-package</span></span><br><span class="line"><span class="comment">    * under that.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.dao..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inDataAccessLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A business service is the execution of any method defined on a service</span></span><br><span class="line"><span class="comment">    * interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">    * &quot;service&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * If you group service interfaces by functional area (for example,</span></span><br><span class="line"><span class="comment">    * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then</span></span><br><span class="line"><span class="comment">    * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;</span></span><br><span class="line"><span class="comment">    * could be used instead.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Alternatively, you can write the expression using the &#x27;bean&#x27;</span></span><br><span class="line"><span class="comment">    * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have</span></span><br><span class="line"><span class="comment">    * named your Spring service beans in a consistent fashion.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp..service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A data access operation is the execution of any method defined on a</span></span><br><span class="line"><span class="comment">    * dao interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">    * &quot;dao&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp.dao.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>您可以在需要切入点表达式的任何地方引用在这样的切面中定义的切入点。例如，要使服务层具有事务性，您可以编写以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut</span>=<span class="string">&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">advice-ref</span>=<span class="string">&quot;tx-advice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;tx-advice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p>Spring AOP 用户可能最常使用<code>execution</code>切入点指示符。执行表达式的格式如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)</span><br><span class="line">                throws-pattern?)</span><br></pre></td></tr></table></figure>

<p>除了返回类型模式(前面的代码段中为<code>ret-type-pattern</code>)，name-pattern和param-pattern以外的所有其他部分都是可选的。返回类型模式确定该方法的返回类型必须是什么才能使连接点匹配， <code>*</code>最常用作返回类型模式，匹配任何返回类型。仅当方法返回给定类型时，完全合格的类型名称才匹配。name-pattern与方法名称匹配。您可以将<code>*</code>通配符用作名称模式的全部或一部分。如果指定了声明类型模式，请在其末尾添加<code>.</code>并将其连接到名称模式组件。param-pattern稍微复杂一些：<code>()</code>匹配不带参数的方法，而<code>(..)</code>匹配任意数量(零个或多个)的参数。 <code>(*)</code>模式与采用任何类型的一个参数的方法匹配。 <code>(*,String)</code>与采用两个参数的方法匹配。第一个可以是任何类型，而第二个必须是<code>String</code>。</p>
<p>以下示例显示了一些常用的切入点表达式：</p>
<ul>
<li>任何公共方法的执行：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>名称以<code>set</code>开头的任何方法的执行：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* set*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AccountService</code>接口定义的任何方法的执行：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service.AccountService.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>service</code>软件包中定义的任何方法的执行：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service.*.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包或其子包之一中定义的任何方法的执行：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service..*.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包中的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(com.xyz.service.*)</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包或其子包之一中的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(com.xyz.service..*)</span><br></pre></td></tr></table></figure>

<ul>
<li>代理实现<code>AccountService</code>接口的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure>

<ul>
<li>目标对象实现<code>AccountService</code>接口的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure>

<ul>
<li>任何采用单个参数且运行时传递的参数为<code>Serializable</code>的连接点(仅在 Spring AOP 中是方法执行)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args(java.io.Serializable)</span><br></pre></td></tr></table></figure>

<p>请注意，此示例中给出的切入点不同于<code>execution(* *(java.io.Serializable))</code>。如果在运行时传递的参数为<code>Serializable</code>，则 args 版本匹配，如果方法签名声明单个类型为<code>Serializable</code>的参数，则执行版本匹配。</p>
<ul>
<li>目标对象带有<code>@Transactional</code>注解的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@target(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目标对象的声明类型具有<code>@Transactional</code>注解 的任何连接点(仅在 Spring AOP 中是方法执行)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@within(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行方法带有<code>@Transactional</code>注解的任何连接点(仅在 Spring AOP 中是方法执行)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@annotation(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>任何采用单个参数且传递的参数的运行时类型具有<code>@Classified</code>注解 的连接点(仅在 Spring AOP 中是方法执行)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@args(com.xyz.security.Classified)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>名为<code>tradeService</code>的 Spring bean 上的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean(tradeService)</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring Bean 上具有与通配符表达式<code>*Service</code>匹配的名称的任何连接点(仅在 Spring AOP 中是方法执行)：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean(*Service)</span><br></pre></td></tr></table></figure>

<h4 id="编写好的切入点"><a href="#编写好的切入点" class="headerlink" title="编写好的切入点"></a>编写好的切入点</h4><p>在编译期间，AspectJ 处理切入点以优化匹配性能。检查代码并确定每个连接点是否(静态或动态)匹配给定的切入点是一个昂贵的过程。 (动态匹配意味着无法从静态分析中完全确定匹配，并且在代码中进行测试以确定在运行代码时是否存在实际匹配)。首次遇到切入点声明时，AspectJ 将其重写为匹配过程的最佳形式。这是什么意思？基本上，切入点以 DNF(析取范式)重写，并且对切入点的组件进行排序，以便首先检查那些较便宜的组件。这意味着您不必担心理解各种切入点指示符的性能，并且可以在切入点声明中以任何 Sequences 提供它们。</p>
<p>但是，AspectJ 只能使用所告诉的内容。为了获得最佳的匹配性能，您应该考虑他们试图达到的目标，并在定义中尽可能缩小匹配的搜索空间。现有的指示符自然分为三类之一：同类，作用域和上下文：</p>
<ul>
<li>亲切的指示者选择一种特定的连接点：<code>execution</code>，<code>get</code>，<code>set</code>，<code>call</code>和<code>handler</code>。</li>
<li>作用域指定者选择一组感兴趣的连接点(可能是多种)：<code>within</code>和<code>withincode</code></li>
<li>上下文指示符根据以下上下文进行匹配(并可选地绑定)：<code>this</code>，<code>target</code>和<code>@annotation</code></li>
</ul>
<p>编写正确的切入点至少应包括前两种类型(种类和作用域)。您可以包括上下文指示符以根据连接点上下文进行匹配，也可以绑定该上下文以在建议中使用。仅提供同类的标识符或仅提供上下文的标识符是可行的，但是由于额外的处理和分析，可能会影响编织性能(使用的时间和内存)。范围指定者的匹配非常快，使用它们的使用意味着 AspectJ 可以非常迅速地消除不应进一步处理的连接点组。一个好的切入点应该始终包括一个切入点。</p>
<h3 id="声明通知"><a href="#声明通知" class="headerlink" title="声明通知"></a>声明通知</h3><p>Advice 与切入点表达式相关联，并在与切入点匹配的方法执行之前、之后或周围运行。切入点表达式可以是对命名切入点的简单引用，也可以是就地声明的切入点表达式。</p>
<h4 id="Before-Advice"><a href="#Before-Advice" class="headerlink" title="Before Advice"></a>Before Advice</h4><p>可以使用<code>@Before</code>注解 在切面中在建议之前声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用就地切入点表达式，则可以将前面的示例重写为以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="After-Returning-Advice"><a href="#After-Returning-Advice" class="headerlink" title="After Returning Advice"></a>After Returning Advice</h4><p>当匹配的方法执行正常返回时，运行<code>After Returning Advice</code>。可以使用<code>@AfterReturning</code>注解进行声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时需要在通知正文中访问返回的实际值。可以使用<code>@AfterReturning</code>的形式绑定返回值以获取该访问权限，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        returning=&quot;retVal&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">(Object retVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>returning</code>属性中使用的名称必须与 advice 方法中的参数名称相对应。当方法执行返回时，该返回值将作为相应的参数值传递到通知方法。 <code>returning</code>子句还将匹配仅限制为返回指定类型值(在这种情况下为<code>Object</code>，该值与任何返回值匹配)的那些方法执行。</p>
<h4 id="After-Throwing-Advice"><a href="#After-Throwing-Advice" class="headerlink" title="After Throwing Advice"></a>After Throwing Advice</h4><p>当匹配的方法执行通过抛出异常退出时，After Throwing Advice运行。可以使用<code>@AfterThrowing</code>注解进行声明，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterThrowingExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望通知仅在引发给定类型的异常时才运行，并且还需要访问通知正文中的异常，可以使用<code>throwing</code>属性来限制匹配(如果需要)(否则，请使用<code>Throwable</code>作为异常类型)，并将抛出的异常绑定到 advice 参数。以下示例显示了如何执行此操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.<span class="keyword">annotation</span>.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.<span class="keyword">annotation</span>.AfterThrowing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterThrowingExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        pointcut=<span class="meta-string">&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;</span>,</span></span><br><span class="line"><span class="meta">        throwing=<span class="meta-string">&quot;ex&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> void doRecoveryActions(DataAccessException ex) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>throwing</code>属性中使用的名称必须与 advice 方法中的参数名称相对应。当通过抛出异常退出方法执行时，该异常将作为相应的参数值传递给通知方法。 <code>throwing</code>子句还将匹配仅限制为抛出指定类型(在本例中为<code>DataAccessException</code>)的异常的方法执行。</p>
<h4 id="After-Finally-Advice"><a href="#After-Finally-Advice" class="headerlink" title="After (Finally) Advice"></a>After (Finally) Advice</h4><p>当匹配的方法执行退出时，After (Finally) Advice运行。通过使用<code>@After</code>注解进行声明。之后必须准备处理正常和异常返回条件的建议。它通常用于释放资源和类似目的。以下示例显示了最终建议后的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterFinallyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReleaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Around-Advice"><a href="#Around-Advice" class="headerlink" title="Around Advice"></a>Around Advice</h4><p>Around Advice“环绕”匹配方法的执行。它有机会在方法运行之前和之后进行工作，并确定方法何时、如何、甚至是否真正开始运行。如果您需要以线程安全的方式（例如，启动和停止计时器）在方法执行前后共享状态，则通常使用环绕通知。始终使用满足您要求的最不强大的通知形式（即，如果 before 通知可以，请不要使用 around 通知）。。</p>
<p>周围的建议通过使用<code>@Around</code>注解 来声明。咨询方法的第一个参数必须为<code>ProceedingJoinPoint</code>类型。在建议的正文中，在<code>ProceedingJoinPoint</code>上调用<code>proceed()</code>会使底层方法执行。 <code>proceed</code>方法也可以传入<code>Object[]</code>。数组中的值用作方法执行时的参数。</p>
<p>以下示例显示了如何使用周围建议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// start stopwatch</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        <span class="comment">// stop stopwatch</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Around Advice返回的值是该方法的调用者看到的返回值。例如，如果一个简单的缓存切面有一个值，则可以从缓存中返回一个值；如果没有，则调用<code>proceed()</code>。请注意，<code>proceed</code>可能在周围建议的正文中被调用一次，多次或完全不被调用。所有这些都是合法的。</p>
<h4 id="Advice-Parameters"><a href="#Advice-Parameters" class="headerlink" title="Advice Parameters"></a>Advice Parameters</h4><p>Spring 提供了完全类型化的建议，这意味着您可以在建议签名中声明所需的参数(如我们先前在返回和抛出示例中所见)，而不是一直使用<code>Object[]</code>数组。我们将在本节的后面部分介绍如何使参数和其他上下文值可用于建议主体。首先，我们看一下如何编写通用建议，以了解该建议当前建议的方法。</p>
<h5 id="访问当前的-JoinPoint"><a href="#访问当前的-JoinPoint" class="headerlink" title="访问当前的 JoinPoint"></a>访问当前的 JoinPoint</h5><p>任何通知方法都可以将类型<code>org.aspectj.lang.JoinPoint</code>的参数声明为第一个参数(请注意，在周围的通知中必须声明类型<code>JoinPoint</code>的子类<code>ProceedingJoinPoint</code>的第一个参数。<code>JoinPoint</code>接口提供了许多有用的方法：</p>
<ul>
<li><code>getArgs()</code>：返回方法参数。</li>
<li><code>getThis()</code>：返回代理对象。</li>
<li><code>getTarget()</code>：返回目标对象。</li>
<li><code>getSignature()</code>：返回建议使用的方法的描述。</li>
<li><code>toString()</code>：打印有关所建议方法的有用描述。</li>
</ul>
<h5 id="将参数传递给Advice"><a href="#将参数传递给Advice" class="headerlink" title="将参数传递给Advice"></a>将参数传递给Advice</h5><p>我们已经看到了如何绑定返回的值或异常值(在返回之后和引发建议之后使用)。要使参数值可用于建议正文，可以使用<code>args</code>的绑定形式。如果在 args 表达式中使用参数名称代替类型名称，则在调用建议时会将相应参数的值作为参数值传递。一个例子应该使这一点更清楚。假设您要建议执行以<code>Account</code>对象作为第一个参数的 DAO 操作，并且您需要访问建议正文中的帐户。您可以编写以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切入点表达式的<code>args(account,..)</code>部分有两个作用。首先，它将匹配限制为仅方法采用至少一个参数并且传递给该参数的参数是<code>Account</code>的实例的方法执行。其次，它通过<code>account</code>参数使实际的<code>Account</code>对象可用于建议。</p>
<p>编写此文件的另一种方法是声明一个切入点，当切入点<code>Account</code>对象值与连接点匹配时，该切入点“提供”，然后从建议中引用命名切入点。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accountDataAccessOperation</span><span class="params">(Account account)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;accountDataAccessOperation(account)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理对象(<code>this</code>)，目标对象(<code>target</code>)和 注解(<code>@within</code>，<code>@target</code>，<code>@annotation</code>和<code>@args</code>)都可以以类似的方式绑定。接下来的两个示例显示如何匹配使用<code>@Auditable</code>注解注解 的方法的执行并提取审核代码：</p>
<p>这两个示例中的第一个显示了<code>@Auditable</code>注解的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Auditable &#123;</span><br><span class="line">    <span class="function">AuditCode <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个示例中的第二个示例显示与<code>@Auditable</code>方法的执行相匹配的建议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="建议参数和泛型"><a href="#建议参数和泛型" class="headerlink" title="建议参数和泛型"></a>建议参数和泛型</h5><p>Spring AOP 可以处理类声明和方法参数中使用的泛型。假设您具有如下通用类型：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Sample</span>&lt;<span class="title">T</span>&gt; &#123;    <span class="function"><span class="keyword">void</span> <span class="title">sampleGenericMethod</span>(<span class="params">T param</span>)</span>;    <span class="function"><span class="keyword">void</span> <span class="title">sampleGenericCollectionMethod</span>(<span class="params">Collection&lt;T&gt; param</span>)</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>您可以通过在要拦截方法的参数类型中键入 advice 参数，将方法类型的拦截限制为某些参数类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)&quot;)</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSampleMethod</span><span class="params">(MyType param)</span> </span>&#123;    <span class="comment">// Advice implementation&#125;</span></span><br></pre></td></tr></table></figure>

<p>这种方法不适用于通用集合。因此，您不能按以下方式定义切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)&quot;)</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSampleMethod</span><span class="params">(Collection&lt;MyType&gt; param)</span> </span>&#123;    <span class="comment">// Advice implementation&#125;</span></span><br></pre></td></tr></table></figure>

<p>为了使这项工作有效，我们将不得不检查集合中的每个元素，这是不合理的，因为我们也无法决定通常如何处理<code>null</code>值。要实现类似目的，您必须将参数键入<code>Collection&lt;?&gt;</code>并手动检查元素的类型。</p>
<h5 id="确定参数名称"><a href="#确定参数名称" class="headerlink" title="确定参数名称"></a>确定参数名称</h5><p>通知调用中的参数绑定依赖于切入点表达式中使用的名称与通知和切入点方法签名中声明的参数名称的匹配。通过 Java 反射无法获得参数名称，因此 Spring AOP 使用以下策略来确定参数名称：</p>
<ul>
<li>如果用户已明确指定参数名称，则使用指定的参数名称。建议和切入点注解都具有可选的<code>argNames</code>属性，您可以使用该属性来指定带注解方法的参数名称。这些参数名称在运行时可用。下面的示例演示如何使用<code>argNames</code>属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,        argNames=&quot;bean,auditable&quot;)</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(Object bean, Auditable auditable)</span> </span>&#123;    AuditCode code = auditable.value();    <span class="comment">// ... use code and bean&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数是<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>或<code>JoinPoint.StaticPart</code>类型，则可以从<code>argNames</code>属性的值中省略参数的名称。例如，如果您修改前面的建议以接收连接点对象，则<code>argNames</code>属性不需要包括它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,        argNames=&quot;bean,auditable&quot;)</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp, Object bean, Auditable auditable)</span> </span>&#123;    AuditCode code = auditable.value();    <span class="comment">// ... use code, bean, and jp&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于不收集任何其他连接点上下文的建议实例，对<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>和<code>JoinPoint.StaticPart</code>类型的第一个参数进行特殊处理特别方便。在这种情况下，您可以省略<code>argNames</code>属性。例如，以下建议无需声明<code>argNames</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod()&quot;)</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp)</span> </span>&#123;    <span class="comment">// ... use jp&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>&#39;argNames&#39;</code>属性有点笨拙，因此，如果未指定<code>&#39;argNames&#39;</code>属性，Spring AOP 将查看该类的调试信息，并尝试从局部变量表中确定参数名称。只要已使用调试信息(至少<code>&#39;-g:vars&#39;</code>)编译了类，就存在此信息。启用此标志时进行编译的结果是：(1)您的代码稍微易于理解(逆向工程)，(2)类文件的大小略大(通常无关紧要)，(3)删除未使用的本地代码的优化变量不适用于您的编译器。换句话说，通过启用该标志，您应该不会遇到任何困难。</li>
</ul>
<p>Note</p>
<p>如果即使没有调试信息，AspectJ 编译器(ajc)都已编译@AspectJ 切面，则无需添加<code>argNames</code>属性，因为编译器会保留所需的信息。</p>
<ul>
<li>如果在没有必要调试信息的情况下编译了代码，Spring AOP 会尝试推断绑定变量与参数的配对(例如，如果切入点表达式中仅绑定了一个变量，并且 advice 方法仅接受一个参数，则配对很明显)。如果在给定可用信息的情况下变量的绑定不明确，则会抛出<code>AmbiguousBindingException</code>。</li>
<li>如果以上所有策略均失败，则抛出<code>IllegalArgumentException</code>。</li>
</ul>
<h5 id="处理参数"><a href="#处理参数" class="headerlink" title="处理参数"></a>处理参数</h5><p>前面我们提到过，我们将描述如何使用在 Spring AOP 和 AspectJ 上始终有效的参数编写<code>proceed</code>调用。解决方案是确保建议签名按 Sequences 绑定每个方法参数。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(List&lt;Account&gt; find*(..)) &amp;&amp; &quot; +        &quot;com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; &quot; +        &quot;args(accountHolderNamePattern)&quot;)</span><span class="function"><span class="keyword">public</span> Object <span class="title">preProcessQueryPattern</span><span class="params">(ProceedingJoinPoint pjp,        String accountHolderNamePattern)</span> <span class="keyword">throws</span> Throwable </span>&#123;    String newPattern = preProcess(accountHolderNamePattern);    <span class="keyword">return</span> pjp.proceed(<span class="keyword">new</span> Object[] &#123;newPattern&#125;);&#125;</span><br></pre></td></tr></table></figure>

<p>在许多情况下，无论如何都要进行此绑定(如上例所示)。</p>
<h4 id="Advice-Ordering"><a href="#Advice-Ordering" class="headerlink" title="Advice Ordering"></a>Advice Ordering</h4><p>当多条建议都希望在同一连接点上运行时会发生什么？ Spring AOP 遵循与 AspectJ 相同的优先级规则来确定建议执行的 Sequences。优先级最高的建议首先“在途中”运行(因此，给定两条优先建议，则优先级最高的建议首先运行)。从连接点“出路”中，优先级最高的建议将最后运行(因此，给定两条后置通知，优先级最高的建议将第二次运行)。</p>
<p>当在不同切面定义的两条建议都需要在同一连接点上运行时，除非另行指定，否则执行 Sequences 是不确定的。您可以通过指定优先级来控制执行 Sequences。通过在 Aspect 类中实现<code>org.springframework.core.Ordered</code>接口或使用<code>Order</code>注解对其进行 注解，可以通过普通的 Spring 方法来完成。给定两个切面，从<code>Ordered.getValue()</code>返回较低值(或注解值)的切面具有较高的优先级。</p>
<p>当在相同切面定义的两条建议都需要在同一连接点上运行时，其 Sequences 是未定义的(因为无法通过反射来获取 javac 编译类的声明 Sequences)。考虑将这些建议方法折叠成每个切面类中每个连接点的一个建议方法，或将建议重构为单独的切面类，您可以在切面级别进行 Order。</p>
<h3 id="Introductions"><a href="#Introductions" class="headerlink" title="Introductions"></a>Introductions</h3><p>简介(在 AspectJ 中称为类型间声明)使切面可以声明建议对象实现给定的接口，并代表那些对象提供该接口的实现。</p>
<p>您可以使用<code>@DeclareParents</code>注解 进行介绍。此注解用于声明匹配类型具有新的父代(因此而得名)。例如，在给定名为<code>UsageTracked</code>的接口和该接口名为<code>DefaultUsageTracked</code>的实现的情况下，以下切面声明服务接口的所有实现者也都实现<code>UsageTracked</code>接口(例如，通过 JMX 公开统计信息)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspectpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;    <span class="meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span>    <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin;    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> </span>&#123;        usageTracked.incrementUseCount();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>要实现的接口由带注解的字段的类型确定。 <code>@DeclareParents</code>注解的<code>value</code>属性是 AspectJ 类型的模式。任何匹配类型的 bean 都实现<code>UsageTracked</code>接口。请注意，在前面示例的建议中，服务 Bean 可以直接用作<code>UsageTracked</code>接口的实现。如果以编程方式访问 bean，则应编写以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="string">&quot;myService&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="切面实例化模型"><a href="#切面实例化模型" class="headerlink" title="切面实例化模型"></a>切面实例化模型</h4><p>Note</p>
<p>这是一个高级主题。如果您刚开始使用 AOP，则可以放心地跳过它，直到以后。</p>
<p>默认情况下，应用程序上下文中每个切面都有一个实例。 AspectJ 将此称为单例实例化模型。可以使用备用生命周期来定义切面。 Spring 支持 AspectJ 的<code>perthis</code>和<code>pertarget</code>实例化模型(当前不支持<code>percflow, percflowbelow,</code>和<code>pertypewithin</code>)。</p>
<p>您可以通过在<code>@Aspect</code>注解中指定<code>perthis</code>子句来声明<code>perthis</code>切面。考虑以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect(&quot;perthis(com.xyz.myapp.SystemArchitecture.businessService())&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> someState;    <span class="meta">@Before(com.xyz.myapp.SystemArchitecture.businessService())</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordServiceUsage</span><span class="params">()</span> </span>&#123;        <span class="comment">// ...    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>在前面的示例中，<code>&#39;perthis&#39;</code>子句的作用是为每个执行业务服务的唯一服务对象(每个与切入点表达式匹配的联接点绑定到“ this”的唯一对象)创建一个切面实例。切面实例是在服务对象上首次调用方法时创建的。当服务对象超出范围时，切面将超出范围。在创建切面实例之前，其中的任何建议都不会执行。创建切面实例后，在其中声明的建议将在匹配的连接点处执行，但仅当服务对象是与此切面相关联的对象时才执行。有关<code>per</code>子句的更多信息，请参见 AspectJ 编程指南。</p>
<p><code>pertarget</code>实例化模型的工作方式与<code>perthis</code>完全相同，但是它为匹配的连接点处的每个唯一目标对象创建一个切面实例。</p>
<h4 id="AOP-示例"><a href="#AOP-示例" class="headerlink" title="AOP 示例"></a>AOP 示例</h4><p>既然您已经了解了所有组成部分是如何工作的，那么我们可以将它们放在一起做一些有用的事情。</p>
<p>有时由于并发问题(例如，死锁失败者)，业务服务的执行可能会失败。如果重试该操作，则很可能在下一次尝试中成功。对于适合在这种情况下重试的业务服务(不需要为解决冲突而需要返回给用户的幂等操作)，我们希望透明地重试该操作以避免 Client 端看到<code>PessimisticLockingFailureException</code>。这项要求清楚地跨越了服务层中的多个服务，因此非常适合通过一个切面实施。</p>
<p>因为我们想重试该操作，所以我们需要使用“周围”建议，以便我们可以多次调用<code>proceed</code>。以下清单显示了基本切面的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspectpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentOperationExecutor</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">2</span>;    <span class="keyword">private</span> <span class="keyword">int</span> maxRetries = DEFAULT_MAX_RETRIES;    <span class="keyword">private</span> <span class="keyword">int</span> order = <span class="number">1</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxRetries</span><span class="params">(<span class="keyword">int</span> maxRetries)</span> </span>&#123;        <span class="keyword">this</span>.maxRetries = maxRetries;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">this</span>.order;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123;        <span class="keyword">this</span>.order = order;    &#125;    <span class="meta">@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)</span>    <span class="function"><span class="keyword">public</span> Object <span class="title">doConcurrentOperation</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;        <span class="keyword">int</span> numAttempts = <span class="number">0</span>;        PessimisticLockingFailureException lockFailureException;        <span class="keyword">do</span> &#123;            numAttempts++;            <span class="keyword">try</span> &#123;                <span class="keyword">return</span> pjp.proceed();            &#125;            <span class="keyword">catch</span>(PessimisticLockingFailureException ex) &#123;                lockFailureException = ex;            &#125;        &#125; <span class="keyword">while</span>(numAttempts &lt;= <span class="keyword">this</span>.maxRetries);        <span class="keyword">throw</span> lockFailureException;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，切面实现了<code>Ordered</code>接口，因此我们可以将切面的优先级设置为高于事务建议(每次重试时都希望有新的事务)。 <code>maxRetries</code>和<code>order</code>属性均由 Spring 配置。主要动作发生在<code>doConcurrentOperation</code>周围建议中。请注意，目前，我们将重试逻辑应用于每个<code>businessService()</code>。我们尝试 continue，如果失败并失败了<code>PessimisticLockingFailureException</code>，我们将重试，除非我们用尽了所有的重试尝试。</p>
<p>相应的 Spring 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;concurrentOperationExecutor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxRetries&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了优化切面，使其仅重试幂等操作，我们可以定义以下<code>Idempotent</code>注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)public <span class="variable">@interface</span> Idempotent &#123;    <span class="comment">// marker annotation&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后，我们可以使用注解来注解服务操作的实现。切面的更改仅重试幂等操作涉及精简切入点表达式，以便只有<code>@Idempotent</code>个操作匹配，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; &quot; +        &quot;@annotation(com.xyz.myapp.service.Idempotent)&quot;)</span><span class="function"><span class="keyword">public</span> Object <span class="title">doConcurrentOperation</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;    ...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于架构的-AOP-支持"><a href="#基于架构的-AOP-支持" class="headerlink" title="基于架构的 AOP 支持"></a>基于架构的 AOP 支持</h2><p>如果您更喜欢基于 XML 的格式，Spring 还支持使用新的<code>aop</code>名称空间标签定义切面。支持与使用@AspectJ 样式时完全相同的切入点表达式和建议类型。因此，在本节中，我们将重点放在新语法上，并使 Reader 参考上一节(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj">@AspectJ support</a>)中的讨论，以了解编写切入点表达式和建议参数的绑定。</p>
<p>要使用本节中描述的 aop 名称空间标签，您需要导入<code>spring-aop</code>模式，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas">基于 XML 模式的配置</a>中所述。有关如何在<code>aop</code>名称空间中导入标签的信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas-aop">AOP 模式</a>。</p>
<p>在您的 Spring 配置中，所有切面和顾问元素都必须放在<code>&lt;aop:config&gt;</code>元素内(在应用程序上下文配置中可以有多个<code>&lt;aop:config&gt;</code>元素)。 <code>&lt;aop:config&gt;</code>元素可以包含切入点，顾问和切面元素(请注意，这些元素必须按此 Sequences 声明)。</p>
<p>Warning</p>
<p><code>&lt;aop:config&gt;</code>样式的配置大量使用了 Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-autoproxy">auto-proxying</a>机制。如果您已经通过使用<code>BeanNameAutoProxyCreator</code>或类似方法来使用显式自动代理，则可能会导致问题(例如未编制建议)。推荐的用法模式是仅使用<code>&lt;aop:config&gt;</code>样式或仅<code>AutoProxyCreator</code>样式，并且不要混合使用。</p>
<h3 id="声明一个切面-1"><a href="#声明一个切面-1" class="headerlink" title="声明一个切面"></a>声明一个切面</h3><p>使用模式支持时，切面是在 Spring 应用程序上下文中定义为 Bean 的常规 Java 对象。状态和行为在对象的字段和方法中捕获，切入点和建议信息在 XML 中捕获。</p>
<p>您可以使用\ &lt;&gt;元素声明一个切面，并使用<code>ref</code>属性引用该支持 bean，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>        ...    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>    ...<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>支持切面(在这种情况下为<code>aBean</code>)的 bean 当然可以像配置任何其他 Spring bean 一样进行配置并注入依赖项。</p>
<h3 id="声明切入点-1"><a href="#声明切入点-1" class="headerlink" title="声明切入点"></a>声明切入点</h3><p>您可以在<code>&lt;aop:config&gt;</code>元素中声明命名的切入点，从而使切入点定义在多个切面和顾问程序之间共享。</p>
<p>可以定义代表服务层中任何业务服务的执行的切入点：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span>        <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，切入点表达式本身使用的是与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj">@AspectJ support</a>中所述的 AspectJ 切入点表达式语言。如果使用基于架构的声明样式，则可以引用在切入点表达式中的类型(@Aspects)中定义的命名切入点。定义上述切入点的另一种方法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span>        <span class="attr">expression</span>=<span class="string">&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假定您具有<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-common-pointcuts">共享通用切入点定义</a>中所述的<code>SystemArchitecture</code>外观。</p>
<p>然后，在切面中声明切入点与声明顶级切入点非常相似，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span>            <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span>        ...    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与@AspectJ 切面几乎相同，使用基于架构的定义样式声明的切入点可以收集连接点上下文。例如，以下切入点收集<code>this</code>对象作为连接点上下文，并将其传递给建议：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span>            <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..)) <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> this(service)&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;businessService&quot;</span> <span class="attr">method</span>=<span class="string">&quot;monitor&quot;</span>/&gt;</span>        ...    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>必须声明通知，以通过包含匹配名称的参数来接收收集的连接点上下文，如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">monitor</span>(<span class="params"><span class="built_in">Object</span> service</span>)</span> &#123;    ...&#125;</span><br></pre></td></tr></table></figure>

<p>组合切入点子表达式时，XML 文档中的<code>&amp;&amp;</code>很尴尬，因此可以分别使用<code>and</code>，<code>or</code>和<code>not</code>关键字代替<code>&amp;&amp;</code>，<code>||</code>和<code>!</code>。例如，上一个切入点可以更好地编写如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span>            <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service..(..)) and this(service)&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;businessService&quot;</span> <span class="attr">method</span>=<span class="string">&quot;monitor&quot;</span>/&gt;</span>        ...    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，以这种方式定义的切入点由其 XML <code>id</code>引用，并且不能用作命名切入点以形成复合切入点。因此，基于架构的定义样式中的命名切入点支持比@AspectJ 样式所提供的更受限制。</p>
<h3 id="声明Advice"><a href="#声明Advice" class="headerlink" title="声明Advice"></a>声明Advice</h3><p>基于模式的 AOP 支持使用与@AspectJ 样式相同的五种建议，并且它们具有完全相同的语义。</p>
<h4 id="Before-Advice-1"><a href="#Before-Advice-1" class="headerlink" title="Before Advice"></a>Before Advice</h4><p>在运行匹配的方法之前，建议运行之前。使用\ &lt;&gt;元素在<code>&lt;aop:aspect&gt;</code>内部声明它，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;beforeExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:before</span>        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span>        <span class="attr">method</span>=<span class="string">&quot;doAccessCheck&quot;</span>/&gt;</span>    ...<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>dataAccessOperation</code>是在最高(<code>&lt;aop:config&gt;</code>)级别定义的切入点的<code>id</code>。要定义切入点内联，请用<code>pointcut</code>属性替换<code>pointcut-ref</code>属性，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;beforeExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:before</span>        <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;</span>        <span class="attr">method</span>=<span class="string">&quot;doAccessCheck&quot;</span>/&gt;</span>    ...<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>正如我们在@AspectJ 样式的讨论中所指出的那样，使用命名的切入点可以显着提高代码的可读性。</p>
<p><code>method</code>属性标识提供建议正文的方法(<code>doAccessCheck</code>)。必须为包含建议的 Aspect 元素所引用的 bean 定义此方法。在执行数据访问操作(与切入点表达式匹配的方法执行连接点)之前，将调用 Aspect Bean 上的<code>doAccessCheck</code>方法。</p>
<h4 id="返回建议后"><a href="#返回建议后" class="headerlink" title="返回建议后"></a>返回建议后</h4><p>返回的建议在匹配的方法执行正常完成时运行。在<code>&lt;aop:aspect&gt;</code>内部以与建议之前相同的方式声明它。以下示例显示了如何声明它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;afterReturningExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:after-returning</span>        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span>        <span class="attr">method</span>=<span class="string">&quot;doAccessCheck&quot;</span>/&gt;</span>    ...<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与@AspectJ 样式一样，您可以在建议正文中获取返回值。为此，使用 returning 属性指定返回值应传递到的参数的名称，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;afterReturningExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:after-returning</span>        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span>        <span class="attr">returning</span>=<span class="string">&quot;retVal&quot;</span>        <span class="attr">method</span>=<span class="string">&quot;doAccessCheck&quot;</span>/&gt;</span>    ...<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>doAccessCheck</code>方法必须声明一个名为<code>retVal</code>的参数。该参数的类型以与<code>@AfterReturning</code>相同的方式约束匹配。例如，您可以声明方法签名，如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">doAccessCheck</span>(<span class="params"><span class="built_in">Object</span> retVal</span>)</span> &#123;...</span><br></pre></td></tr></table></figure>

<h4 id="提出建议后"><a href="#提出建议后" class="headerlink" title="提出建议后"></a>提出建议后</h4><p>抛出建议后，当匹配的方法执行通过抛出异常退出时执行建议。通过使用掷后元素在<code>&lt;aop:aspect&gt;</code>内部声明它，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;afterThrowingExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:after-throwing</span>        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span>        <span class="attr">method</span>=<span class="string">&quot;doRecoveryActions&quot;</span>/&gt;</span>    ...<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与@AspectJ 样式一样，您可以在通知正文中获取引发的异常。为此，请使用 throwing 属性指定异常应传递到的参数的名称，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;afterThrowingExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:after-throwing</span>        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span>        <span class="attr">throwing</span>=<span class="string">&quot;dataAccessEx&quot;</span>        <span class="attr">method</span>=<span class="string">&quot;doRecoveryActions&quot;</span>/&gt;</span>    ...<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>doRecoveryActions</code>方法必须声明一个名为<code>dataAccessEx</code>的参数。该参数的类型以与<code>@AfterThrowing</code>相同的方式约束匹配。例如，方法签名可以声明如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">doRecoveryActions</span>(<span class="params">DataAccessException dataAccessEx</span>)</span> &#123;...</span><br></pre></td></tr></table></figure>

<h4 id="最后-建议后"><a href="#最后-建议后" class="headerlink" title="(最后)建议后"></a>(最后)建议后</h4><p>无论最终如何执行匹配的方法，建议(最终)都会运行。您可以使用<code>after</code>元素对其进行声明，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;afterFinallyExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:after</span>        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span>        <span class="attr">method</span>=<span class="string">&quot;doReleaseLock&quot;</span>/&gt;</span>    ...<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Around-Advice-1"><a href="#Around-Advice-1" class="headerlink" title="Around Advice"></a>Around Advice</h4><p>最后一种建议是围绕建议。围绕建议在匹配的方法执行过程中“围绕”运行。它有机会在方法执行之前和之后进行工作，并确定何时，如何以及什至根本不执行该方法。周围建议通常用于以线程安全的方式(例如，启动和停止计时器)在方法执行之前和之后共享状态。始终使用最不强大的建议形式，以满足您的要求。如果建议可以完成这项工作，请不要在建议周围使用。</p>
<p>您可以使用<code>aop:around</code>元素在建议周围进行声明。咨询方法的第一个参数必须为<code>ProceedingJoinPoint</code>类型。在建议的正文中，在<code>ProceedingJoinPoint</code>上调用<code>proceed()</code>会导致基础方法执行。 <code>proceed</code>方法也可以用<code>Object[]</code>调用。数组中的值用作方法执行时的参数。有关使用<code>Object[]</code>调用<code>proceed</code>的说明，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-around-advice">Around Advice</a>。以下示例显示了如何在 XML 中围绕建议进行声明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;aroundExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:around</span>        <span class="attr">pointcut-ref</span>=<span class="string">&quot;businessService&quot;</span>        <span class="attr">method</span>=<span class="string">&quot;doBasicProfiling&quot;</span>/&gt;</span>    ...<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>doBasicProfiling</code>通知的实现可以与@AspectJ 示例完全相同(当然要减去 注解)，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;    <span class="comment">// start stopwatch    Object retVal = pjp.proceed();    // stop stopwatch    return retVal;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Advice-Parameters-1"><a href="#Advice-Parameters-1" class="headerlink" title="Advice Parameters"></a>Advice Parameters</h4><p>基于架构的声明样式以与@AspectJ 支持相同的方式支持完全类型的建议，即通过名称与建议方法参数匹配切入点参数。有关详情，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-params">Advice Parameters</a>。如果您希望显式指定建议方法的参数名称(不依赖于先前描述的检测策略)，则可以通过使用建议元素的<code>arg-names</code>属性来实现，该属性与<code>argNames</code>属性的处理方式相同。建议 注解(如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-params-names">确定参数名称</a>中所述)。以下示例显示如何在 XML 中指定参数名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:before    pointcut=<span class="string">&quot;com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)&quot;</span>    method=<span class="string">&quot;audit&quot;</span>    <span class="built_in">arg</span>-names=<span class="string">&quot;auditable&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p><code>arg-names</code>属性接受逗号分隔的参数名称列表。</p>
<p>以下基于 XSD 的方法中涉及程度稍高的示例显示了一些与一些强类型参数结合使用的建议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y.service;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> </span>&#123;    <span class="function">Person <span class="title">getPerson</span><span class="params">(String personName, <span class="keyword">int</span> age)</span></span>;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFooService</span> <span class="keyword">implements</span> <span class="title">FooService</span> </span>&#123;    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是切面。请注意，<code>profile(..)</code>方法接受许多强类型的参数，第一个恰好是用于进行方法调用的连接点。此参数的存在表明<code>profile(..)</code>用作<code>around</code>建议，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;<span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<span class="keyword">import</span> org.springframework.util.StopWatch;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProfiler</span> </span>&#123;    <span class="function"><span class="keyword">public</span> Object <span class="title">profile</span><span class="params">(ProceedingJoinPoint call, String name, <span class="keyword">int</span> age)</span> <span class="keyword">throws</span> Throwable </span>&#123;        StopWatch clock = <span class="keyword">new</span> StopWatch(<span class="string">&quot;Profiling for &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + age + <span class="string">&quot;&#x27;&quot;</span>);        <span class="keyword">try</span> &#123;            clock.start(call.toShortString());            <span class="keyword">return</span> call.proceed();        &#125; <span class="keyword">finally</span> &#123;            clock.stop();            System.out.println(clock.prettyPrint());        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>最后，以下示例 XML 配置影响了特定连接点的上述建议的执行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span>    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span>    <span class="comment">&lt;!-- this is the object that will be proxied by Spring&#x27;s AOP infrastructure --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultPersonService&quot;</span>/&gt;</span>    <span class="comment">&lt;!-- this is the actual advice itself --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;profiler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.SimpleProfiler&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;profiler&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;theExecutionOfSomePersonServiceMethod&quot;</span>                <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.PersonService.getPerson(String,int))                and args(name, age)&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;theExecutionOfSomePersonServiceMethod&quot;</span>                <span class="attr">method</span>=<span class="string">&quot;profile&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>考虑以下驱动程序脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;<span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="keyword">import</span> x.y.service.PersonService;<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        BeanFactory ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;x/y/plain.xml&quot;</span>);        PersonService person = (PersonService) ctx.getBean(<span class="string">&quot;personService&quot;</span>);        person.getPerson(<span class="string">&quot;Pengo&quot;</span>, <span class="number">12</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>有了这样的 Boot 类，我们将在标准输出上获得类似于以下内容的输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StopWatch <span class="string">&#x27;Profiling for &#x27;</span>Pengo<span class="string">&#x27; and &#x27;</span><span class="number">12</span><span class="string">&#x27;&#x27;</span>: <span class="built_in">running</span> <span class="built_in">time</span> (millis) = <span class="number">0</span><span class="comment">-----------------------------------------ms     %     Task name-----------------------------------------00000  ?  execution(getFoo)</span></span><br></pre></td></tr></table></figure>

<h4 id="Advice-Ordering-1"><a href="#Advice-Ordering-1" class="headerlink" title="Advice Ordering"></a>Advice Ordering</h4><p>当需要在同一连接点(执行方法)上执行多个建议时，排序规则如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-ordering">Advice Ordering</a>中所述。切面之间的优先级是通过将<code>Order</code>注解添加到支持切面的 Bean 或通过使 Bean 实现<code>Ordered</code>接口来确定的。</p>
<h3 id="Introductions-1"><a href="#Introductions-1" class="headerlink" title="Introductions"></a>Introductions</h3><p>简介(在 AspectJ 中称为类型间声明)使切面可以声明建议的对象实现给定的接口，并代表那些对象提供该接口的实现。</p>
<p>您可以使用<code>aop:aspect</code>内的<code>aop:declare-parents</code>元素进行介绍。您可以使用<code>aop:declare-parents</code>元素来声明匹配类型具有新的父代(因此而得名)。例如，给定名为<code>UsageTracked</code>的接口和该名为<code>DefaultUsageTracked</code>的接口的实现，以下切面声明服务接口的所有实现者也都实现<code>UsageTracked</code>接口。 (例如，为了通过 JMX 公开统计信息.)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;usageTrackerAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;usageTracking&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:declare-parents</span>        <span class="attr">types-matching</span>=<span class="string">&quot;com.xzy.myapp.service.*+&quot;</span>        <span class="attr">implement-interface</span>=<span class="string">&quot;com.xyz.myapp.service.tracking.UsageTracked&quot;</span>        <span class="attr">default-impl</span>=<span class="string">&quot;com.xyz.myapp.service.tracking.DefaultUsageTracked&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">aop:before</span>        <span class="attr">pointcut</span>=<span class="string">&quot;com.xyz.myapp.SystemArchitecture.businessService()            and this(usageTracked)&quot;</span>            <span class="attr">method</span>=<span class="string">&quot;recordUsage&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>支持<code>usageTracking</code> bean 的类将包含以下方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">recordUsage</span>(<span class="params">UsageTracked usageTracked</span>)</span> &#123;    usageTracked.incrementUseCount();&#125;</span><br></pre></td></tr></table></figure>

<p>要实现的接口由<code>implement-interface</code>属性确定。 <code>types-matching</code>属性的值是 AspectJ 类型的模式。任何匹配类型的 bean 都实现<code>UsageTracked</code>接口。请注意，在前面示例的建议中，服务 Bean 可以直接用作<code>UsageTracked</code>接口的实现。要以编程方式访问 bean，可以编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="string">&quot;myService&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="5-5-5-切面实例化模型"><a href="#5-5-5-切面实例化模型" class="headerlink" title="5.5.5. 切面实例化模型"></a>5.5.5. 切面实例化模型</h4><p>模式定义切面唯一受支持的实例化模型是单例模型。在将来的版本中可能会支持其他实例化模型。</p>
<h4 id="5-5-6-Advisors"><a href="#5-5-6-Advisors" class="headerlink" title="5.5.6. Advisors"></a>5.5.6. Advisors</h4><p>“顾问”的概念来自 Spring 中定义的 AOP 支持，并且在 AspectJ 中没有直接等效的概念。顾问就像一个独立的小切面，只有一条建议。通知本身由 bean 表示，并且必须实现<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api-advice-types">Spring 的建议类型</a>中描述的建议接口之一。顾问可以利用 AspectJ 切入点表达式。</p>
<p>Spring 通过<code>&lt;aop:advisor&gt;</code>元素支持顾问程序概念。您通常会看到它与事务建议结合使用，事务建议在 Spring 中也有自己的名称空间支持。以下示例显示顾问程序：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span>        <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">aop:advisor</span>        <span class="attr">pointcut-ref</span>=<span class="string">&quot;businessService&quot;</span>        <span class="attr">advice-ref</span>=<span class="string">&quot;tx-advice&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;tx-advice&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span>        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了前面的示例中使用的<code>pointcut-ref</code>属性，还可以使用<code>pointcut</code>属性来内联定义切入点表达式。</p>
<p>要定义顾问程序的优先级，以便该建议书可以参与 Order，请使用<code>order</code>属性来定义顾问程序的<code>Ordered</code>值。</p>
<h4 id="5-5-7-AOP-模式示例"><a href="#5-5-7-AOP-模式示例" class="headerlink" title="5.5.7. AOP 模式示例"></a>5.5.7. AOP 模式示例</h4><p>本节显示了使用模式支持重写时来自<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-example">AOP 示例</a>的并发锁定失败重试示例的外观。</p>
<p>有时由于并发问题(例如，死锁失败者)，业务服务的执行可能会失败。如果重试该操作，则很可能在下一次尝试中成功。对于适合在这种情况下重试的业务服务(不需要为解决冲突而需要返回给用户的幂等操作)，我们希望透明地重试该操作以避免 Client 端看到<code>PessimisticLockingFailureException</code>。这项要求清楚地跨越了服务层中的多个服务，因此非常适合通过一个切面实施。</p>
<p>因为我们想重试该操作，所以我们需要使用“周围”建议，以便我们可以多次调用<code>proceed</code>。以下清单显示了基本切面的实现(这是使用模式支持的常规 Java 类)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentOperationExecutor</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">2</span>;    <span class="keyword">private</span> <span class="keyword">int</span> maxRetries = DEFAULT_MAX_RETRIES;    <span class="keyword">private</span> <span class="keyword">int</span> order = <span class="number">1</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxRetries</span><span class="params">(<span class="keyword">int</span> maxRetries)</span> </span>&#123;        <span class="keyword">this</span>.maxRetries = maxRetries;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">this</span>.order;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123;        <span class="keyword">this</span>.order = order;    &#125;    <span class="function"><span class="keyword">public</span> Object <span class="title">doConcurrentOperation</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;        <span class="keyword">int</span> numAttempts = <span class="number">0</span>;        PessimisticLockingFailureException lockFailureException;        <span class="keyword">do</span> &#123;            numAttempts++;            <span class="keyword">try</span> &#123;                <span class="keyword">return</span> pjp.proceed();            &#125;            <span class="keyword">catch</span>(PessimisticLockingFailureException ex) &#123;                lockFailureException = ex;            &#125;        &#125; <span class="keyword">while</span>(numAttempts &lt;= <span class="keyword">this</span>.maxRetries);        <span class="keyword">throw</span> lockFailureException;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，切面实现了<code>Ordered</code>接口，因此我们可以将切面的优先级设置为高于事务建议(每次重试时都希望有新的事务)。 <code>maxRetries</code>和<code>order</code>属性均由 Spring 配置。主要动作发生在<code>doConcurrentOperation</code>周围建议方法中。我们尝试 continue。如果我们失败了<code>PessimisticLockingFailureException</code>，我们将重试，除非我们用尽了所有的重试尝试。</p>
<p>Note</p>
<p>该类与@AspectJ 示例中使用的类相同，但是除去了 注解。</p>
<p>相应的 Spring 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;concurrentOperationRetry&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;concurrentOperationExecutor&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;idempotentOperation&quot;</span>            <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">aop:around</span>            <span class="attr">pointcut-ref</span>=<span class="string">&quot;idempotentOperation&quot;</span>            <span class="attr">method</span>=<span class="string">&quot;doConcurrentOperation&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;concurrentOperationExecutor&quot;</span>    <span class="attr">class</span>=<span class="string">&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxRetries&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，目前我们假设所有业务服务都是幂等的。如果不是这种情况，我们可以通过引入<code>Idempotent</code>注解 并使用该注解来注解服务操作的实现，来改进切面，使其仅重试 true 的幂等操作，如以下示例所示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)public <span class="variable">@interface</span> Idempotent &#123;    <span class="comment">// marker annotation&#125;</span></span><br></pre></td></tr></table></figure>

<p>切面的更改仅重试幂等操作涉及精简切入点表达式，以便只有<code>@Idempotent</code>个操作匹配，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;idempotentOperation&quot;</span>        <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..)) and        @annotation(com.xyz.myapp.service.Idempotent)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="选择要使用的-AOP-声明样式"><a href="#选择要使用的-AOP-声明样式" class="headerlink" title="选择要使用的 AOP 声明样式"></a>选择要使用的 AOP 声明样式</h2><p>一旦确定切面是实现给定需求的最佳方法，您如何在使用 Spring AOP 或 AspectJ 以及在 Aspect 语言(代码)样式，@ AspectJ 注解样式或 Spring XML 样式之间做出选择？这些决定受许多因素影响，包括应用程序需求，开发工具以及团队对 AOP 的熟悉程度。</p>
<h3 id="5-6-1-Spring-AOP-还是-Full-AspectJ？"><a href="#5-6-1-Spring-AOP-还是-Full-AspectJ？" class="headerlink" title="5.6.1. Spring AOP 还是 Full AspectJ？"></a>5.6.1. Spring AOP 还是 Full AspectJ？</h3><p>使用最简单的方法即可。 Spring AOP 比使用完整的 AspectJ 更简单，因为不需要在开发和构建过程中引入 AspectJ 编译器/编织器。如果您只需要建议在 Spring bean 上执行操作，则 Spring AOP 是正确的选择。如果您需要建议不受 Spring 容器 Management 的对象(通常是域对象)，则需要使用 AspectJ。如果您希望建议除简单方法执行以外的连接点(例如，字段 get 或设置连接点等)，则还需要使用 AspectJ。</p>
<p>使用 AspectJ 时，可以选择 AspectJ 语言语法(也称为“代码样式”)或@AspectJ注解 样式。显然，如果您不使用 Java 5，那么将为您做出选择：使用代码样式。如果切面在您的设计中起着重要作用，并且您能够将<a target="_blank" rel="noopener" href="https://www.eclipse.org/ajdt/">AspectJ 开发工具(AJDT)</a>插件用于 Eclipse，则 AspectJ 语言语法是首选。它更干净，更简单，因为该语言是专为编写切面而设计的。如果您不使用 Eclipse 或只有少数几个切面在您的应用程序中不起作用，那么您可能要考虑使用@AspectJ 样式，在 IDE 中坚持常规 Java 编译，并向其中添加切面编织阶段您的构建脚本。</p>
<h3 id="5-6-2-AspectJ-或-Spring-AOP-的-XML？"><a href="#5-6-2-AspectJ-或-Spring-AOP-的-XML？" class="headerlink" title="5.6.2. @AspectJ 或 Spring AOP 的 XML？"></a>5.6.2. @AspectJ 或 Spring AOP 的 XML？</h3><p>如果选择使用 Spring AOP，则可以选择@AspectJ 或 XML 样式。有各种折衷考虑。</p>
<p>XML 样式可能是现有 Spring 用户最熟悉的，并且得到了 true 的 POJO 的支持。当使用 AOP 作为配置企业服务的工具时，XML 可能是一个不错的选择(一个很好的测试是您是否将切入点表达式视为配置的一部分，您可能希望独立更改)。使用 XML 样式，可以说从您的配置中可以更清楚地了解系统中存在哪些切面。</p>
<p>XML 样式有两个缺点。首先，它没有完全将要解决的需求的实现封装在一个地方。 DRY 原则说，系统中的任何知识都应该有单一，明确，Authority 的表示形式。当使用 XML 样式时，关于如何实现需求的知识会在配置文件中的后备 bean 类的声明和 XML 中分散。当您使用@AspectJ 样式时，此信息将封装在一个单独的模块中：切面。其次，与@AspectJ 样式相比，XML 样式在表达能力上有更多限制：仅支持“单例”切面实例化模型，并且无法组合以 XML 声明的命名切入点。例如，使用@AspectJ 样式，您可以编写如下内容：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Pointcut</span>(<span class="string">&quot;execution(* get*())&quot;</span>)public void propertyAccess() &#123;&#125;<span class="variable">@Pointcut</span>(<span class="string">&quot;execution(org.xyz.Account+ *(..))&quot;</span>)public void operationReturningAnAccount() &#123;&#125;<span class="variable">@Pointcut</span>(<span class="string">&quot;propertyAccess() &amp;&amp; operationReturningAnAccount()&quot;</span>)public void accountPropertyAccess() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在 XML 样式中，您可以声明前两个切入点：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;propertyAccess&quot;</span>        <span class="attr">expression</span>=<span class="string">&quot;execution(* get*())&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;operationReturningAnAccount&quot;</span>        <span class="attr">expression</span>=<span class="string">&quot;execution(org.xyz.Account+ *(..))&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>XML 方法的缺点是无法通过组合这些定义来定义<code>accountPropertyAccess</code>切入点。</p>
<p>@AspectJ 样式支持其他实例化模型和更丰富的切入点组合。它具有将切面保持为模块化单元的优势。它还具有的优点是，Spring AOP 和 AspectJ 都可以理解@AspectJ 切面。因此，如果您以后决定需要 AspectJ 的功能来实现其他要求，则可以轻松地迁移到基于 AspectJ 的方法。总而言之，只要您拥有比简单地配置企业服务更多的功能，Spring 团队就会喜欢@AspectJ 样式。</p>
<h2 id="5-7-混合切面类型"><a href="#5-7-混合切面类型" class="headerlink" title="5.7. 混合切面类型"></a>5.7. 混合切面类型</h2><p>通过使用自动代理支持，模式定义的<code>&lt;aop:aspect&gt;</code>切面，<code>&lt;aop:advisor&gt;</code>声明的顾问程序，甚至是在同一配置中使用 Spring 1.2 样式定义的代理和拦截器，完全可以混合使用@AspectJ 样式的切面。所有这些都是通过使用相同的基础支持机制实现的，并且可以毫无困难地共存。</p>
<h2 id="5-8-代理机制"><a href="#5-8-代理机制" class="headerlink" title="5.8. 代理机制"></a>5.8. 代理机制</h2><p>Spring AOP 使用 JDK 动态代理或 CGLIB 创建给定目标对象的代理。 (只要有选择，首选 JDK 动态代理)。</p>
<p>如果要代理的目标对象实现至少一个接口，则使用 JDK 动态代理。代理了由目标类型实现的所有接口。如果目标对象未实现任何接口，则将创建 CGLIB 代理。</p>
<p>如果要强制使用 CGLIB 代理(例如，代理为目标对象定义的每个方法，而不仅是由其接口实现的方法)，都可以这样做。但是，您应该考虑以下问题：</p>
<ul>
<li>不能建议<code>final</code>方法，因为它们不能被覆盖。</li>
<li>从 Spring 3.2 开始，不再需要将 CGLIB 添加到您的项目 Classpath 中，因为 CGLIB 类在<code>org.springframework</code>下重新打包并直接包含在 spring-core JAR 中。这意味着基于 CGLIB 的代理支持“有效”，就像 JDK 动态代理始终具有的一样。</li>
<li>从 Spring 4.0 开始，由于 CGLIB 代理实例是通过 Objenesis 创建的，因此不再调用代理对象的构造函数两次。仅当您的 JVM 不允许绕过构造函数时，您才可能从 Spring 的 AOP 支持中看到两次调用和相应的调试日志条目。</li>
</ul>
<p>要强制使用 CGLIB 代理，请将<code>&lt;aop:config&gt;</code>元素的<code>proxy-target-class</code>属性的值设置为 true，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span>    <span class="comment">&lt;!-- other beans defined here... --&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要在使用@AspectJ 自动代理支持时强制 CGLIB 代理，请将<code>&lt;aop:aspectj-autoproxy&gt;</code>元素的<code>proxy-target-class</code>属性设置为<code>true</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy proxy-target-<span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>多个<code>&lt;aop:config/&gt;</code>节在运行时折叠到一个统一的自动代理创建器中，该创建器将应用<code>&lt;aop:config/&gt;</code>节中的任何(通常来自不同 XML bean 定义文件)指定的* strong *代理设置。这也适用于<code>&lt;tx:annotation-driven/&gt;</code>和<code>&lt;aop:aspectj-autoproxy/&gt;</code>元素。</p>
<p>明确地说，在<code>&lt;tx:annotation-driven/&gt;</code>，<code>&lt;aop:aspectj-autoproxy/&gt;</code>或<code>&lt;aop:config/&gt;</code>元素上使用<code>proxy-target-class=&quot;true&quot;</code>会强制对所有三个元素*使用 CGLIB 代理。</p>
<h3 id="5-8-1-了解-AOP-代理"><a href="#5-8-1-了解-AOP-代理" class="headerlink" title="5.8.1. 了解 AOP 代理"></a>5.8.1. 了解 AOP 代理</h3><p>Spring AOP 是基于代理的。在编写自己的切面或使用 Spring Framework 随附的任何基于 Spring AOP 的切面之前，掌握最后一条语句实际含义的语义至关重要。</p>
<p>首先考虑您有一个普通的，未经代理的，没有什么特别的，直接的对象引用的情况，如以下代码片段所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePojo</span> <span class="title">implements</span> <span class="title">Pojo</span> </span>&#123;    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;        <span class="comment">// this next method invocation is a direct call on the &#x27;this&#x27; reference        this.bar();    &#125;    public void bar() &#123;        // some logic...    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果在对象引用上调用方法，则直接在该对象引用上调用该方法，如下图和清单所示：</p>
<p><img src="/2021/08/22/Java/spring/Spring-AOP/aop-proxy-plain-pojo-call.png" alt="aop 代理普通 pojo 电话"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;        Pojo pojo = <span class="keyword">new</span> SimplePojo();        <span class="comment">// this is a direct method call on the &#x27;pojo&#x27; reference        pojo.foo();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>当 Client 端代码具有的引用是代理时，情况会稍有变化。考虑以下图表和代码片段：</p>
<p><img src="/2021/08/22/Java/spring/Spring-AOP/aop-proxy-call.png" alt="aop 代理呼叫"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());        factory.addInterface(Pojo.class);        factory.addAdvice(<span class="keyword">new</span> RetryAdvice());        Pojo pojo = (Pojo) factory.getProxy();        <span class="comment">// this is a method call on the proxy!        pojo.foo();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里要理解的关键是，<code>Main</code>类的<code>main(..)</code>方法内部的 Client 端代码具有对代理的引用。这意味着该对象引用上的方法调用是代理上的调用。结果，代理可以委派给与该特定方法调用相关的所有拦截器(建议)。但是，一旦调用最终到达目标对象(在这种情况下为<code>SimplePojo</code>，则为<code>this.bar()</code>或<code>this.foo()</code>)，则将针对<code>this</code>引用而不是对<code>this</code>引用调用它可能对其自身进行的任何方法调用。代理。这具有重要的意义。这意味着自调用不会导致与方法调用相关的建议得到执行的机会。</p>
<p>好吧，那么该怎么办？最好的方法(此处宽松地使用术语“最好”)是重构代码，以免发生自调用。这确实需要您做一些工作，但这是最好的，侵入性最小的方法。下一种方法绝对可怕，我们正要指出这一点，恰恰是因为它是如此可怕。您可以(对我们来说是痛苦的)完全将类中的逻辑与 Spring AOP 绑定在一起，如以下示例所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePojo</span> <span class="title">implements</span> <span class="title">Pojo</span> </span>&#123;    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;        <span class="comment">// this works, but... gah!        ((Pojo) AopContext.currentProxy()).bar();    &#125;    public void bar() &#123;        // some logic...    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这将您的代码完全耦合到 Spring AOP，并且使类本身意识到在 AOP 上下文中使用它这一事实，而 AOP 却是事实。创建代理时，还需要一些其他配置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());        factory.adddInterface(Pojo.class);        factory.addAdvice(<span class="keyword">new</span> RetryAdvice());        factory.setExposeProxy(<span class="keyword">true</span>);        Pojo pojo = (Pojo) factory.getProxy();        <span class="comment">// this is a method call on the proxy!        pojo.foo();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>最后，必须注意，AspectJ 没有此自调用问题，因为它不是基于代理的 AOP 框架。</p>
<h2 id="5-9-以编程方式创建-AspectJ-代理"><a href="#5-9-以编程方式创建-AspectJ-代理" class="headerlink" title="5.9. 以编程方式创建@AspectJ 代理"></a>5.9. 以编程方式创建@AspectJ 代理</h2><p>除了使用<code>&lt;aop:config&gt;</code>或<code>&lt;aop:aspectj-autoproxy&gt;</code>声明配置中的各个切面外，还可以通过编程方式创建建议目标对象的代理。有关 Spring 的 AOP API 的完整详细信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api">next chapter</a>。在这里，我们要重点介绍通过使用@AspectJ 切面自动创建代理的功能。</p>
<p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code>类为一个或多个@AspectJ 切面建议的目标对象创建代理。此类的基本用法非常简单，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a factory that can generate a proxy for the given target objectAspectJProxyFactory factory = new AspectJProxyFactory(targetObject);// add an aspect, the class must be an @AspectJ aspect// you can call this as many times as you need with different aspectsfactory.addAspect(SecurityManager.class);// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspectfactory.addAspect(usageTracker);// now get the proxy object...MyInterfaceType proxy = factory.getProxy();</span></span><br></pre></td></tr></table></figure>

<p>有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.html">javadoc</a>。</p>
<h2 id="5-10-在-Spring-应用程序中使用-AspectJ"><a href="#5-10-在-Spring-应用程序中使用-AspectJ" class="headerlink" title="5.10. 在 Spring 应用程序中使用 AspectJ"></a>5.10. 在 Spring 应用程序中使用 AspectJ</h2><p>到目前为止，本章介绍的所有内容都是纯 Spring AOP。在本节中，我们将研究如果您的需求超出了 Spring AOP 所提供的功能，那么如何使用 AspectJ 编译器或 weaver 代替 Spring AOP 或除 Spring AOP 之外使用。</p>
<p>Spring 附带了一个小的 AspectJ 切面库，该库在您的发行版中可以作为<code>spring-aspects.jar</code>独立使用。您需要将其添加到 Classpath 中才能使用其中的切面。 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-atconfigurable">使用 AspectJ 通过 Spring 依赖注入域对象</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ajlib-other">AspectJ 的其他 Spring 切面</a>讨论了该库的内容以及如何使用它。 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-configure">使用 Spring IoC 配置 AspectJ Aspects</a>讨论如何依赖注入使用 AspectJ 编译器编织的 AspectJ 切面。最后，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">在 Spring Framework 中使用 AspectJ 进行加载时编织</a>介绍了使用 AspectJ 的 Spring 应用程序的加载时编织。</p>
<h3 id="5-10-1-使用-AspectJ-通过-Spring-依赖注入域对象"><a href="#5-10-1-使用-AspectJ-通过-Spring-依赖注入域对象" class="headerlink" title="5.10.1. 使用 AspectJ 通过 Spring 依赖注入域对象"></a>5.10.1. 使用 AspectJ 通过 Spring 依赖注入域对象</h3><p>Spring 容器实例化并配置在您的应用程序上下文中定义的 bean。给定包含要应用的配置的 Bean 定义的名称，也可以要求 Bean 工厂配置预先存在的对象。 <code>spring-aspects.jar</code>包含注解驱动的切面，该切面利用此功能允许任何对象的依赖项注入。该支架旨在用于在任何容器的控制范围之外创建的对象。域对象通常属于此类，因为它们通常是通过<code>new</code>运算符或通过 ORM 工具以数据库查询的方式通过程序创建的。</p>
<p><code>@Configurable</code>注解 将一个类标记为符合 Spring 驱动的配置。在最简单的情况下，您可以将其纯粹用作标记 注解，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.myapp.domain;<span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Configurable;<span class="meta">@Configurablepublic</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>当以这种方式用作标记接口时，Spring 通过使用具有与完全限定类型名称(<code>com.xyz.myapp.domain.Account</code>)同名的 bean 定义(通常为原型作用域)来配置带注解类型的新实例(在本例中为<code>Account</code>)。 。由于 Bean 的默认名称是其类型的完全限定名称，因此声明原型定义的便捷方法是省略<code>id</code>属性，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xyz.myapp.domain.Account&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fundsTransferService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fundsTransferService&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要显式指定要使用的原型 bean 定义的名称，则可以直接在注解中这样做，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.myapp.domain;<span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Configurable;<span class="meta">@Configurable(<span class="meta-string">&quot;account&quot;</span>)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>Spring 现在查找名为<code>account</code>的 bean 定义，并将其用作配置新<code>Account</code>实例的定义。</p>
<p>您也可以使用自动装配来避免完全指定专用的 bean 定义。要让 Spring 应用自动装配，请使用<code>@Configurable</code>注解的<code>autowire</code>属性。您可以分别按类型或名称指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code>或<code>@Configurable(autowire=Autowire.BY_NAME</code>自动布线。或者，从 Spring 2.5 开始，最好在字段或方法级别使用<code>@Autowired</code>或<code>@Inject</code>为<code>@Configurable</code> bean 指定显式的，注解 驱动的依赖项注入(有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config">基于注解的容器配置</a>)。</p>
<p>最后，您可以使用<code>dependencyCheck</code>属性(例如<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>)为新创建和配置的对象中的对象引用启用 Spring 依赖项检查。如果此属性设置为<code>true</code>，则 Spring 在配置后验证是否已设置所有属性(不是基元或集合)。</p>
<p>请注意，单独使用注解不会执行任何操作。注解 中存在的是<code>spring-aspects.jar</code>中的<code>AnnotationBeanConfigurerAspect</code>。从本质上讲，切面说：“在从带有<code>@Configurable</code>注解 的类型的新对象的初始化返回之后，根据注解的属性使用 Spring 配置新创建的对象”。在这种情况下，“初始化”是指新实例化的对象(例如，用<code>new</code>运算符实例化的对象)以及正在反序列化(例如，通过<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html">readResolve()</a>)的<code>Serializable</code>对象。</p>
<p>Note</p>
<p>上段中的关键短语之一是“本质上”。对于大多数情况，“从新对象的初始化返回后”的确切语义是可以的。在这种情况下，“初始化之后”是指在构造对象之后注入依赖项。这意味着该依赖项不可在类的构造函数体中使用。如果要在构造函数主体执行之前注入依赖项，从而可以在构造函数主体中使用这些依赖项，则需要在<code>@Configurable</code>声明中定义此变量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configurable(preConstruction=true)</span></span><br></pre></td></tr></table></figure>

<p>您可以在<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ 编程指南</a>的 AspectJ <a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">在本附录中</a>中找到有关各种切入点类型的语言语义的更多信息。</p>
<p>为此，必须将带注解的类型与 AspectJ 编织器编织在一起。您可以使用构建时 Ant 或 Maven 任务来执行此操作(例如，参见__)，也可以使用加载时编织(请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">在 Spring Framework 中使用 AspectJ 进行加载时编织</a>)。 <code>AnnotationBeanConfigurerAspect</code>本身需要由 Spring 配置(以获取对将用于配置新对象的 Bean 工厂的引用)。如果使用基于 Java 的配置，则可以将<code>@EnableSpringConfigured</code>添加到任何<code>@Configuration</code>类中，如下所示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span><span class="variable">@EnableSpringConfiguredpublic</span> class AppConfig &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果您喜欢基于 XML 的配置，Spring <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas-context">context namespace</a>定义了一个方便的<code>context:spring-configured</code>元素，您可以按以下方式使用它：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;context:spring-configured/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在配置切面之前创建的<code>@Configurable</code>个对象的实例导致向调试日志发出一条消息，并且未进行任何对象配置。一个示例可能是 Spring 配置中的 bean，当它由 Spring 初始化时会创建域对象。在这种情况下，可以使用<code>depends-on</code> bean 属性来手动指定该 bean 取决于配置切面。下面的示例演示如何使用<code>depends-on</code>属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myService&quot;</span>        <span class="attr">class</span>=<span class="string">&quot;com.xzy.myapp.service.MyService&quot;</span>        <span class="attr">depends-on</span>=<span class="string">&quot;org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect&quot;</span>&gt;</span>    <span class="comment">&lt;!-- ... --&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>除非您真的想在运行时依赖它的语义，否则不要通过 bean configurer 切面激活<code>@Configurable</code>处理。特别是，请确保不要在已通过容器注册为常规 Spring bean 的 bean 类上使用<code>@Configurable</code>。这样做将导致两次初始化，一次是通过容器，一次是通过切面。</p>
<h4 id="单元测试-Configurable-对象"><a href="#单元测试-Configurable-对象" class="headerlink" title="单元测试@Configurable 对象"></a>单元测试@Configurable 对象</h4><p><code>@Configurable</code>支持的目标之一是实现域对象的独立单元测试，而不会遇到与硬编码查找相关的困难。如果 AspectJ 尚未编织<code>@Configurable</code>类型，则注解在单元测试期间不起作用。您可以在被测对象中设置模拟或存根属性引用，然后照常进行。如果<code>@Configurable</code>类型是 AspectJ 编织的，您仍然可以像往常一样在容器外部进行单元测试，但是每次构造<code>@Configurable</code>对象时，都会看到一条警告消息，指示该对象尚未由 Spring 配置。</p>
<h4 id="处理多个应用程序上下文"><a href="#处理多个应用程序上下文" class="headerlink" title="处理多个应用程序上下文"></a>处理多个应用程序上下文</h4><p>用于实现<code>@Configurable</code>支持的<code>AnnotationBeanConfigurerAspect</code>是 AspectJ 单例切面。单例切面的范围与<code>static</code>成员的范围相同：每个类加载器都有一个切面实例来定义类型。这意味着，如果您在同一个类加载器层次结构中定义多个应用程序上下文，则需要考虑在哪里定义<code>@EnableSpringConfigured</code> bean 以及在哪里将<code>spring-aspects.jar</code>放在 Classpath 上。</p>
<p>考虑一个典型的 Spring Web 应用程序配置，该配置具有一个共享的父应用程序上下文，该上下文定义了通用的业务服务，支持那些服务所需的一切，以及每个 Servlet 的一个子应用程序上下文(其中包含该 Servlet 的特定定义)。所有这些上下文共存于相同的类加载器层次结构中，因此<code>AnnotationBeanConfigurerAspect</code>只能保留对其中一个的引用。在这种情况下，我们建议在共享(父)应用程序上下文中定义<code>@EnableSpringConfigured</code> bean。这定义了您可能想注入域对象的服务。结果是，您无法使用@Configurable 机制来配置域对象，该域对象引用的是在子(特定于 servlet 的)上下文中定义的 bean 的引用(无论如何，这可能不是您想做的事情)。</p>
<p>在同一容器中部署多个 Web 应用程序时，请确保每个 Web 应用程序使用自己的类加载器(例如，将<code>spring-aspects.jar</code>放在<code>&#39;WEB-INF/lib&#39;</code>中)加载<code>spring-aspects.jar</code>中的类型。如果<code>spring-aspects.jar</code>仅添加到容器级的 Classpath 中(并因此由共享的父类加载器加载)，则所有 Web 应用程序都共享相同的切面实例(这可能不是您想要的)。</p>
<h3 id="5-10-2-AspectJ-的其他-Spring-切面"><a href="#5-10-2-AspectJ-的其他-Spring-切面" class="headerlink" title="5.10.2. AspectJ 的其他 Spring 切面"></a>5.10.2. AspectJ 的其他 Spring 切面</h3><p>除了<code>@Configurable</code>切面之外，<code>spring-aspects.jar</code>还包含一个 AspectJ 切面，您可以使用它来驱动 Spring 的事务 Management，该事务 Management 使用<code>@Transactional</code>注解 进行注解的类型和方法。这主要适用于希望在 Spring 容器之外使用 Spring Framework 的事务支持的用户。</p>
<p>解释<code>@Transactional</code>注解 的切面是<code>AnnotationTransactionAspect</code>。使用此切面时，必须注解实现类(或该类中的方法或两者)，而不是注解该类所实现的接口(如果有)。 AspectJ 遵循 Java 的规则，即不继承接口上的 注解。</p>
<p>类上的<code>@Transactional</code>注解 指定用于执行该类中任何公共操作的默认事务语义。</p>
<p>类内方法上的<code>@Transactional</code>注解 将覆盖类 注解(如果存在)给出的默认事务语义。可以标注任何可见性的方法，包括私有方法。直接注解非公共方法是执行此类方法而获得事务划分的唯一方法。</p>
<p>Tip</p>
<p>从 Spring Framework 4.2 开始，<code>spring-aspects</code>提供了类似的切面，为标准<code>javax.transaction.Transactional</code>注解 提供了完全相同的功能。检查<code>JtaAnnotationTransactionAspect</code>了解更多详细信息。</p>
<p>对于希望使用 Spring 配置和事务 Management 支持但又不想(或不能)使用注解的 AspectJ 程序员，<code>spring-aspects.jar</code>还包含<code>abstract</code>个切面，您可以扩展它们以提供自己的切入点定义。有关更多信息，请参见<code>AbstractBeanConfigurerAspect</code>和<code>AbstractTransactionAspect</code>切面的资源。例如，以下摘录显示了如何编写切面来使用与完全限定的类名匹配的原型 Bean 定义来配置域模型中定义的对象的所有实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect &#123;    <span class="function"><span class="keyword">public</span> <span class="title">DomainObjectConfiguration</span><span class="params">()</span> </span>&#123;        setBeanWiringInfoResolver(<span class="keyword">new</span> ClassNameBeanWiringInfoResolver());    &#125;    <span class="comment">// the creation of a new bean (any object in the domain model)    protected pointcut beanCreation(Object beanInstance) :        initialization(new(..)) &amp;&amp;        SystemArchitecture.inDomainModel() &amp;&amp;        this(beanInstance);&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-10-3-使用-Spring-IoC-配置-AspectJ-Aspects"><a href="#5-10-3-使用-Spring-IoC-配置-AspectJ-Aspects" class="headerlink" title="5.10.3. 使用 Spring IoC 配置 AspectJ Aspects"></a>5.10.3. 使用 Spring IoC 配置 AspectJ Aspects</h3><p>当您将 AspectJ 切面与 Spring 应用程序一起使用时，既自然又希望能够使用 Spring 配置这些切面。 AspectJ 运行时本身负责切面的创建，并且通过 Spring 配置 AspectJ 创建的切面的方法取决于切面所使用的 AspectJ 实例化模型(<code>per-xxx</code>子句)。</p>
<p>AspectJ 的大多数切面都是单例切面。这些切面的配置很容易。您可以创建一个正常引用外观类型并包含<code>factory-method=&quot;aspectOf&quot;</code> bean 属性的 bean 定义。这可以确保 Spring 通过向 AspectJ 索要长宽比实例，而不是尝试自己创建实例来获得长宽比实例。下面的示例演示如何使用<code>factory-method=&quot;aspectOf&quot;</code>属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;profiler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xyz.profiler.Profiler&quot;</span>        <span class="attr">factory-method</span>=<span class="string">&quot;aspectOf&quot;</span>&gt;</span> (1)    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;profilingStrategy&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jamonProfilingStrategy&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>(1)</strong> 请注意<code>factory-method=&quot;aspectOf&quot;</code>属性</li>
</ul>
<p>非单一切面很难配置。但是，可以通过创建原型 bean 定义并使用<code>spring-aspects.jar</code>的<code>@Configurable</code>支持来配置切面实例(一旦 AspectJ 运行时创建了 bean)来实现。</p>
<p>如果您有一些要与 AspectJ 编织的@AspectJ 切面(例如，对域模型类型使用加载时编织)以及要与 Spring AOP 一起使用的其他@AspectJ 切面，那么这些切面都已在 Spring 中配置，您需要告诉 Spring AOP @AspectJ 自动代理支持，应使用配置中定义的@AspectJ 切面的确切子集进行自动代理。您可以使用<code>&lt;aop:aspectj-autoproxy/&gt;</code>声明中的一个或多个<code>&lt;include/&gt;</code>元素来完成此操作。每个<code>&lt;include/&gt;</code>元素都指定一个名称模式，并且只有名称与至少一个模式匹配的 bean 才可用于 Spring AOP 自动代理配置。以下示例显示了如何使用<code>&lt;include/&gt;</code>元素：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;aop:aspectj-autoproxy&gt;    &lt;aop:include name=&quot;thisBean&quot;/&gt;    &lt;aop:include name=&quot;thatBean&quot;/&gt;&lt;/aop:aspectj-autoproxy&gt;</span></span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>不要被<code>&lt;aop:aspectj-autoproxy/&gt;</code>元素的名称所迷惑。使用它可以创建 Spring AOP 代理。此处使用了@AspectJ 样式的声明，但是不涉及 AspectJ 运行时。</p>
<h3 id="5-10-4-在-Spring-Framework-中使用-AspectJ-进行加载时编织"><a href="#5-10-4-在-Spring-Framework-中使用-AspectJ-进行加载时编织" class="headerlink" title="5.10.4. 在 Spring Framework 中使用 AspectJ 进行加载时编织"></a>5.10.4. 在 Spring Framework 中使用 AspectJ 进行加载时编织</h3><p>加载时编织(LTW)是指在将 AspectJ 切面加载到应用程序的类文件中时将它们编织到 Java 虚拟机(JVM)中的过程。本部分的重点是在 Spring 框架的特定上下文中配置和使用 LTW。本节不是 LTW 的一般介绍。有关 LTW 的详细信息以及仅使用 AspectJ 配置 LTW(完全不涉及 Spring)的详细信息，请参见<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">AspectJ 开发环境指南的 LTW 部分</a>。</p>
<p>Spring 框架为 AspectJ LTW 带来的价值在于能够对编织过程进行更精细的控制。 “香草” AspectJ LTW 通过使用 Java(5)代理来实现，该代理通过在启动 JVM 时指定 VM 参数来打开。因此，它是一个 JVM 范围的设置，在某些情况下可能很好，但通常有点过于粗糙。启用了 Spring 的 LTW 允许您以<code>ClassLoader</code>为基础打开 LTW，它的粒度更细，并且在“单 JVM-多应用程序”环境中(例如在典型的应用程序服务器中发现)更有意义。环境)。</p>
<p>此外，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-environments">在某些环境中</a>，此支持可实现加载时编织，而无需对添加<code>-javaagent:path/to/aspectjweaver.jar</code>或<code>-javaagent:path/to/org.springframework.instrument-&#123;version&#125;.jar</code>(以前称为<code>spring-agent.jar</code>)所需的应用服务器的启动脚本进行任何修改。开发人员可以修改构成应用程序上下文的一个或多个文件，以实现加载时编织，而不必依赖通常负责部署配置(例如启动脚本)的 Management 员。</p>
<p>现在，销售工作已经结束，让我们首先浏览一个使用 Spring 的 AspectJ LTW 的快速示例，然后详细介绍示例中引入的元素。有关完整示例，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-petclinic">Petclinicsample 申请</a>。</p>
<h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><p>假设您是一位负责诊断系统中某些性能问题的原因的应用程序开发人员。与其使用分析工具，不如使用一个简单的分析切面，使我们能够快速获得一些性能 Metrics。然后，我们可以立即在该特定区域应用更细粒度的分析工具。</p>
<p>Note</p>
<p>此处提供的示例使用 XML 配置。您还可以将<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java">Java configuration</a>配置和使用@AspectJ。具体来说，您可以使用<code>@EnableLoadTimeWeaving</code>注解 替代<code>&lt;context:load-time-weaver/&gt;</code>(有关详细信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-spring">below</a>)。</p>
<p>下面的示例显示了配置切面，它不是花哨的-它是基于时间的探查器，它使用@AspectJ 样式的切面声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;<span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="keyword">import</span> org.aspectj.lang.annotation.Around;<span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;<span class="keyword">import</span> org.springframework.util.StopWatch;<span class="keyword">import</span> org.springframework.core.annotation.Order;<span class="meta">@Aspectpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfilingAspect</span> </span>&#123;    <span class="meta">@Around(&quot;methodsToBeProfiled()&quot;)</span>    <span class="function"><span class="keyword">public</span> Object <span class="title">profile</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;        StopWatch sw = <span class="keyword">new</span> StopWatch(getClass().getSimpleName());        <span class="keyword">try</span> &#123;            sw.start(pjp.getSignature().getName());            <span class="keyword">return</span> pjp.proceed();        &#125; <span class="keyword">finally</span> &#123;            sw.stop();            System.out.println(sw.prettyPrint());        &#125;    &#125;    <span class="meta">@Pointcut(&quot;execution(public * foo..*.*(..))&quot;)</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodsToBeProfiled</span><span class="params">()</span></span>&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>我们还需要创建一个<code>META-INF/aop.xml</code>文件，以通知 AspectJ 编织者我们要将<code>ProfilingAspect</code>编织到类中。此文件约定，即在 JavaClasspath 上名为<code>META-INF/aop.xml</code>的文件，是标准 AspectJ。下面的示例显示<code>aop.xml</code>文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">aspectj</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//AspectJ//DTD//EN&quot;</span> <span class="meta-string">&quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span>    <span class="tag">&lt;<span class="name">weaver</span>&gt;</span>        <span class="comment">&lt;!-- only weave classes in our application-specific packages --&gt;</span>        <span class="tag">&lt;<span class="name">include</span> <span class="attr">within</span>=<span class="string">&quot;foo.*&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">weaver</span>&gt;</span>    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span>        <span class="comment">&lt;!-- weave in just this aspect --&gt;</span>        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">&quot;foo.ProfilingAspect&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们可以 continue 进行配置中特定于 Spring 的部分。我们需要配置一个<code>LoadTimeWeaver</code>(稍后说明)。此加载时织布器是必不可少的组件，负责将一个或多个<code>META-INF/aop.xml</code>文件中的切面配置编织到应用程序的类中。好处是，它不需要很多配置(您可以指定一些其他选项，但是稍后会详细介绍)，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="comment">&lt;!-- a service object; we will be profiling its methods --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;entitlementCalculationService&quot;</span>            <span class="attr">class</span>=<span class="string">&quot;foo.StubEntitlementCalculationService&quot;</span>/&gt;</span>    <span class="comment">&lt;!-- this switches on the load-time weaving --&gt;</span>    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，所有必需的构件(切面，<code>META-INF/aop.xml</code>文件和 Spring 配置)都就位了，我们可以使用<code>main(..)</code>方法创建以下驱动程序类，以演示实际的 LTW：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;<span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>, Main.class);        EntitlementCalculationService entitlementCalculationService            = (EntitlementCalculationService) ctx.getBean(<span class="string">&quot;entitlementCalculationService&quot;</span>);        <span class="comment">// the profiling aspect is &#x27;woven&#x27; around this method execution        entitlementCalculationService.calculateEntitlement();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们还有最后一件事要做。本节的引言确实说过，可以使用 Spring 以<code>ClassLoader</code>为基础选择性地打开 LTW，这是事实。但是，在此示例中，我们使用 Java 代理(Spring 随附)打开 LTW。我们使用以下命令运行前面显示的<code>Main</code>类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:C:<span class="regexp">/projects/</span>foo/lib/<span class="built_in">global</span>/spring-instrument.jar foo.Main</span><br></pre></td></tr></table></figure>

<p><code>-javaagent</code>是用于指定和启用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">代理来检测在 JVM 上运行的程序</a>的标志。 Spring 框架附带了这样的代理<code>InstrumentationSavingAgent</code>，该代理打包在<code>spring-instrument.jar</code>中，在上一示例中，该代理作为<code>-javaagent</code>自变量的值提供。</p>
<p><code>Main</code>程序的执行输出类似于下一个示例。 (我在<code>calculateEntitlement()</code>实现中引入了<code>Thread.sleep(..)</code>语句，以便探查器实际上捕获的不是 0 毫秒(<code>01234</code>毫秒不是 AOP 引入的开销)。以下清单显示了运行探查器时得到的输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calculating entitlementStopWatch <span class="string">&#x27;ProfilingAspect&#x27;</span>: <span class="built_in">running</span> <span class="built_in">time</span> (millis) = <span class="number">1234</span><span class="comment">------ ----- ----------------------------ms     %     Task name------ ----- ----------------------------01234  100%  calculateEntitlement</span></span><br></pre></td></tr></table></figure>

<p>由于此 LTW 是通过使用成熟的 AspectJ 来实现的，因此我们不仅限于建议 Spring Bean。 <code>Main</code>程序的以下细微变化会产生相同的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;<span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>, Main.class);        EntitlementCalculationService entitlementCalculationService =            <span class="keyword">new</span> StubEntitlementCalculationService();        <span class="comment">// the profiling aspect will be &#x27;woven&#x27; around this method execution        entitlementCalculationService.calculateEntitlement();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意，在前面的程序中，我们如何引导 Spring 容器，然后完全在 Spring 上下文之外创建<code>StubEntitlementCalculationService</code>的新实例。剖析建议仍会被应用。</p>
<p>诚然，这个例子很简单。但是，在前面的示例中已经介绍了 Spring 对 LTW 支持的基础，本节的其余部分详细解释了每一位配置和用法的“原因”。</p>
<p>Note</p>
<p>在此示例中使用的<code>ProfilingAspect</code>可能是基本的，但很有用。这是开发时切面的一个很好的示例，开发人员可以在开发过程中使用它，然后轻松地将其从部署到 UAT 或 Producing 的应用程序构建中排除。</p>
<h4 id="Aspects"><a href="#Aspects" class="headerlink" title="Aspects"></a>Aspects</h4><p>您在 LTW 中使用的切面必须是 AspectJ 切面。您可以使用 AspectJ 语言本身来编写它们，也可以使用@AspectJ 风格来编写切面。这样，您的切面就是有效的 AspectJ 和 Spring AOP 切面。此外，编译的切面类需要在 Classpath 上可用。</p>
<h4 id="‘META-INF-aop-xml’"><a href="#‘META-INF-aop-xml’" class="headerlink" title="‘META-INF/aop.xml’"></a>‘META-INF/aop.xml’</h4><p>通过使用 JavaClasspath 上的一个或多个<code>META-INF/aop.xml</code>文件(直接或通常在 jar 文件中)来配置 AspectJ LTW 基础结构。</p>
<p>该文件的结构和内容在 LTW 部分<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">AspectJ 参考文档</a>中详细介绍。由于 aop.xml 文件是 100％AspectJ，因此在此不再赘述。</p>
<h4 id="必需的库-JARS"><a href="#必需的库-JARS" class="headerlink" title="必需的库(JARS)"></a>必需的库(JARS)</h4><p>至少，您需要以下库来使用 Spring Framework 对 AspectJ LTW 的支持：</p>
<ul>
<li><code>spring-aop.jar</code>(2.5 版或更高版本，以及所有强制性依赖项)</li>
<li><code>aspectjweaver.jar</code>(1.6.8 版或更高版本)</li>
</ul>
<p>如果您使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-environment-generic">Spring 提供的代理程序可实现检测</a>，则还需要：</p>
<ul>
<li><code>spring-instrument.jar</code></li>
</ul>
<h4 id="Spring-Configuration"><a href="#Spring-Configuration" class="headerlink" title="Spring Configuration"></a>Spring Configuration</h4><p>Spring 的 LTW 支持中的关键组件是<code>LoadTimeWeaver</code>接口(在<code>org.springframework.instrument.classloading</code>包中)，以及 Spring 发行版附带的众多实现。 <code>LoadTimeWeaver</code>负责在运行时将一个或多个<code>java.lang.instrument.ClassFileTransformers</code>添加到<code>ClassLoader</code>，这为各种有趣的应用程序打开了大门，其中之一恰好是切面的 LTW。</p>
<p>Tip</p>
<p>如果您不熟悉运行时类文件转换的概念，请在 continue 之前先查看<code>java.lang.instrument</code>软件包的 javadoc API 文档。虽然该文档并不全面，但是至少您可以看到关键的接口和类(在您阅读本节时作为参考)。</p>
<p>为特定的<code>ApplicationContext</code>配置<code>LoadTimeWeaver</code>就像添加一行一样容易。 (请注意，您几乎肯定需要使用<code>ApplicationContext</code>作为您的 Spring 容器—通常，<code>BeanFactory</code>是不够的，因为 LTW 支持使用<code>BeanFactoryPostProcessors</code>.)</p>
<p>要启用 Spring Framework 的 LTW 支持，您需要配置<code>LoadTimeWeaver</code>，通常通过使用<code>@EnableLoadTimeWeaving</code>注解来完成，如下所示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span><span class="variable">@EnableLoadTimeWeavingpublic</span> class AppConfig &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果您更喜欢基于 XML 的配置，请使用<code>&lt;context:load-time-weaver/&gt;</code>元素。请注意，该元素是在<code>context</code>名称空间中定义的。以下示例显示了如何使用<code>&lt;context:load-time-weaver/&gt;</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面的配置会自动为您定义并注册许多 LTW 特定的基础结构 Bean，例如<code>LoadTimeWeaver</code>和<code>AspectJWeavingEnabler</code>。缺省<code>LoadTimeWeaver</code>是<code>DefaultContextLoadTimeWeaver</code>类，它将尝试装饰自动检测到的<code>LoadTimeWeaver</code>。 “自动检测到”的<code>LoadTimeWeaver</code>的确切类型取决于您的运行时环境。下表总结了各种<code>LoadTimeWeaver</code>实现：</p>
<p>*表 13. DefaultContextLoadTimeWeaver LoadTimeWeavers *</p>
<table>
<thead>
<tr>
<th>Runtime Environment</th>
<th><code>LoadTimeWeaver</code>实施</th>
</tr>
</thead>
<tbody><tr>
<td>在 Oracle 的<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic</a>中运行</td>
<td><code>WebLogicLoadTimeWeaver</code></td>
</tr>
<tr>
<td>在 Oracle 的<a target="_blank" rel="noopener" href="http://glassfish.dev.java.net/">GlassFish</a>中运行</td>
<td><code>GlassFishLoadTimeWeaver</code></td>
</tr>
<tr>
<td>在<a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Apache Tomcat</a>中运行</td>
<td><code>TomcatLoadTimeWeaver</code></td>
</tr>
<tr>
<td>在 Red Hat 的<a target="_blank" rel="noopener" href="http://www.jboss.org/jbossas/">JBoss AS</a>或<a target="_blank" rel="noopener" href="http://www.wildfly.org/">WildFly</a>中运行</td>
<td><code>JBossLoadTimeWeaver</code></td>
</tr>
<tr>
<td>在 IBM 的<a target="_blank" rel="noopener" href="https://www-01.ibm.com/software/webservers/appserv/was/">WebSphere</a>中运行</td>
<td><code>WebSphereLoadTimeWeaver</code></td>
</tr>
<tr>
<td>JVM 从 Spring <code>InstrumentationSavingAgent</code>(<code>java -javaagent:path/to/spring-instrument.jar</code>)开始</td>
<td><code>InstrumentationLoadTimeWeaver</code></td>
</tr>
<tr>
<td>回退，期望基础 ClassLoader 遵循通用约定(例如适用于<code>TomcatInstrumentableClassLoader</code>和<a target="_blank" rel="noopener" href="http://www.caucho.com/">Resin</a>)</td>
<td><code>ReflectiveLoadTimeWeaver</code></td>
</tr>
</tbody></table>
<p>请注意，该表仅列出了使用<code>DefaultContextLoadTimeWeaver</code>时自动检测到的<code>LoadTimeWeavers</code>。您可以确切指定要使用的<code>LoadTimeWeaver</code>实现。</p>
<p>要使用 Java 配置指定特定的<code>LoadTimeWeaver</code>，请实现<code>LoadTimeWeavingConfigurer</code>接口并覆盖<code>getLoadTimeWeaver()</code>方法。以下示例指定<code>ReflectiveLoadTimeWeaver</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span><span class="variable">@EnableLoadTimeWeavingpublic</span> class AppConfig implements LoadTimeWeavingConfigurer &#123;    <span class="variable">@Override</span>    public LoadTimeWeaver getLoadTimeWeaver() &#123;        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">ReflectiveLoadTimeWeaver</span>();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用基于 XML 的配置，则可以将完全限定的类名指定为<code>&lt;context:load-time-weaver/&gt;</code>元素上的<code>weaver-class</code>属性的值。同样，以下示例指定<code>ReflectiveLoadTimeWeaver</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>            <span class="attr">weaver-class</span>=<span class="string">&quot;org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以后可以使用众所周知的名称<code>loadTimeWeaver</code>从 Spring 容器中检索由配置定义和注册的<code>LoadTimeWeaver</code>。请记住，<code>LoadTimeWeaver</code>仅作为 Spring 的 LTW 基础结构添加一个或多个<code>ClassFileTransformers</code>的机制而存在。执行 LTW 的实际<code>ClassFileTransformer</code>是<code>ClassPreProcessorAgentAdapter</code>(来自<code>org.aspectj.weaver.loadtime</code>程序包)类。有关更多详细信息，请参见<code>ClassPreProcessorAgentAdapter</code>类的类级 javadoc，因为实际上如何实现编织的细节不在本文档的讨论范围之内。</p>
<p>还需要讨论配置的最后一个属性：<code>aspectjWeaving</code>属性(如果使用 XML，则为<code>aspectj-weaving</code>)。此属性控制是否启用 LTW。它接受三个可能的值之一，如果属性不存在，则默认值为<code>autodetect</code>。下表总结了三个可能的值：</p>
<p><em>表 14. AspectJ 编织属性值</em></p>
<table>
<thead>
<tr>
<th>Annotation Value</th>
<th>XML Value</th>
<th>Explanation</th>
</tr>
</thead>
<tbody><tr>
<td><code>ENABLED</code></td>
<td><code>on</code></td>
<td>AspectJ 正在编织，并且在加载时适当地编织了切面。</td>
</tr>
<tr>
<td><code>DISABLED</code></td>
<td><code>off</code></td>
<td>LTW 已关闭。加载时不会编织任何切面。</td>
</tr>
<tr>
<td><code>AUTODETECT</code></td>
<td><code>autodetect</code></td>
<td>如果 Spring LTW 基础结构可以找到至少一个<code>META-INF/aop.xml</code>文件，则表示 AspectJ 编织已开始。否则，它关闭。这是默认值。</td>
</tr>
</tbody></table>
<h4 id="Environment-specific-Configuration"><a href="#Environment-specific-Configuration" class="headerlink" title="Environment-specific Configuration"></a>Environment-specific Configuration</h4><p>最后一部分包含在应用程序服务器和 Web 容器等环境中使用 Spring 的 LTW 支持时所需的所有其他设置和配置。</p>
<h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><p>从历史上看，<a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Apache Tomcat</a>的默认类加载器不支持类转换，因此 Spring 提供了增强的实现来满足此需求。名为<code>TomcatInstrumentableClassLoader</code>的加载程序可在 Tomcat 6.0 及更高版本上运行。</p>
<p>Tip</p>
<p>不要在 Tomcat 8.0 及更高版本上定义<code>TomcatInstrumentableClassLoader</code>。相反，让 Spring 通过<code>TomcatLoadTimeWeaver</code>策略自动使用 Tomcat 的新本机<code>InstrumentableClassLoader</code>工具。</p>
<p>如果仍然需要使用<code>TomcatInstrumentableClassLoader</code>，则可以为每个 Web 应用程序分别进行注册，如下所示：</p>
<ul>
<li>将<code>org.springframework.instrument.tomcat.jar</code>复制到<code>$CATALINA_HOME/lib</code>，其中<code>$CATALINA_HOME</code>代表 Tomcat 安装的根目录</li>
<li>通过编辑 Web 应用程序上下文文件，指示 Tomcat 使用自定义类加载器(而不是默认值)，如以下示例所示：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/myWebApp&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;/my/webApp/location&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">Loader</span>        <span class="attr">loaderClass</span>=<span class="string">&quot;org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Apache Tomcat 6.0 支持多个上下文位置：</p>
<ul>
<li>服务器配置文件：<code>$CATALINA_HOME/conf/server.xml</code></li>
<li>默认上下文配置：<code>$CATALINA_HOME/conf/context.xml</code>，这会影响所有已部署的 Web 应用程序</li>
<li>每个 Web 应用程序配置，可以在<code>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</code>部署在服务器端，也可以在<code>META-INF/context.xml</code>嵌入在 Web 应用程序存档中</li>
</ul>
<p>为了提高效率，我们建议使用嵌入式的逐个 Web 应用程序配置样式，因为它只影响使用自定义类加载器的应用程序，并且不需要对服务器配置进行任何更改。有关可用上下文位置的更多详细信息，请参见 Tomcat 6.0.x <a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-6.0-doc/config/context.html">documentation</a>。</p>
<p>或者，考虑使用 Spring 提供的通用 VM 代理，该代理在 Tomcat 的启动脚本中指定(本节前面已描述)。这使得检测对所有已部署的 Web 应用程序均可用，无论它们运行在<code>ClassLoader</code>上。</p>
<h6 id="WebLogic，WebSphere，Resin，GlassFish-和-JBoss"><a href="#WebLogic，WebSphere，Resin，GlassFish-和-JBoss" class="headerlink" title="WebLogic，WebSphere，Resin，GlassFish 和 JBoss"></a>WebLogic，WebSphere，Resin，GlassFish 和 JBoss</h6><p>最新版本的 WebLogic Server(版本 10 和更高版本)，IBM WebSphere Application Server(版本 7 和更高版本)，Resin(版本 3.1 和更高版本)以及 JBoss(版本 6.x 或更高版本)提供了<code>ClassLoader</code>并能够进行本地检测。 Spring 的本地 LTW 利用此类 ClassLoader 实现来实现 AspectJ 编织。您可以通过激活加载时编织来启用 LTW，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-using-aspectj">described earlier</a>。具体来说，您无需修改启动脚本即可添加<code>-javaagent:path/to/spring-instrument.jar</code>。</p>
<p>请注意，具有 GlassFish 工具功能的<code>ClassLoader</code>仅在其 EAR 环境中可用。对于 GlassFish Web 应用程序，请遵循 Tomcat 设置说明<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-environment-tomcat">outlined earlier</a>。</p>
<p>请注意，在 JBoss 6.x 上，您需要禁用应用服务器扫描，以防止它在应用程序实际启动之前加载类。一个快速的解决方法是将名为<code>WEB-INF/jboss-scanning.xml</code>的文件添加到您的工件中，其中包含以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scanning</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:jboss:scanning:1.0&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通用-Java-应用程序"><a href="#通用-Java-应用程序" class="headerlink" title="通用 Java 应用程序"></a>通用 Java 应用程序</h4><p>在不支持或现有<code>LoadTimeWeaver</code>实现不支持的环境中需要类检测时，JDK 代理可以是唯一的解决方案。对于这种情况，Spring 提供了<code>InstrumentationLoadTimeWeaver</code>，这需要一个 Spring 特定(但非常通用)的 VM 代理<code>org.springframework.instrument-&#123;version&#125;.jar</code>(以前称为<code>spring-agent.jar</code>)。</p>
<p>要使用它，您必须通过提供以下 JVM 选项来使用 Spring 代理启动虚拟机：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:<span class="regexp">/path/</span>to/org.springframework.instrument-&#123;version&#125;.jar</span><br></pre></td></tr></table></figure>

<p>请注意，这需要修改 VM 启动脚本，这可能会阻止您在应用程序服务器环境中使用它(取决于您的操作策略)。此外，JDK 代理会检测整个 VM，这可能会很昂贵。</p>
<p>出于性能原因，我们建议仅在目标环境(例如<a target="_blank" rel="noopener" href="https://www.eclipse.org/jetty/">Jetty</a>)没有(或不支持)专用 LTW 的情况下才使用此配置。</p>
<h2 id="5-11-更多资源"><a href="#5-11-更多资源" class="headerlink" title="5.11. 更多资源"></a>5.11. 更多资源</h2><p>可以在<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj">AspectJ website</a>上找到有关 AspectJ 的更多信息。</p>
<ul>
<li>Adrian Colyer 等人的《 Eclipse AspectJ *》。等(Addison-Wesley，2005 年)为 AspectJ 语言提供了全面的介绍和参考。</li>
</ul>
<p>强烈推荐 Ramnivas Laddad(Manning，2009)出版的《 AspectJ in Action *》第二版。本书的重点是 AspectJ，但在一定程度上探讨了许多通用的 AOP 主题。</p>
<h2 id="6-Spring-AOP-API"><a href="#6-Spring-AOP-API" class="headerlink" title="6. Spring AOP API"></a>6. Spring AOP API</h2><p>上一章使用@AspectJ 和基于模式的切面定义描述了 Spring 对 AOP 的支持。在本章中，我们讨论较低级别的 Spring AOP API 和通常在 Spring 1.2 应用程序中使用的 AOP 支持。对于新应用程序，我们建议使用上一章中介绍的 Spring 2.0 和更高版本的 AOP 支持。但是，当您使用现有应用程序(或阅读书籍和文章)时，可能会遇到 Spring 1.2 样式的示例。 Spring 5 仍然与 Spring 1.2 向后兼容，Spring 5 完全支持本章中描述的所有内容。</p>
<h3 id="6-1-Spring-中的-Pointcut-API"><a href="#6-1-Spring-中的-Pointcut-API" class="headerlink" title="6.1. Spring 中的 Pointcut API"></a>6.1. Spring 中的 Pointcut API</h3><p>本节描述了 Spring 如何处理关键切入点概念。</p>
<h4 id="6-1-1-Concepts"><a href="#6-1-1-Concepts" class="headerlink" title="6.1.1. Concepts"></a>6.1.1. Concepts</h4><p>Spring 的切入点模型使切入点重用不受建议类型的影响。您可以使用相同的切入点来定位不同的建议。</p>
<p><code>org.springframework.aop.Pointcut</code>界面是中央界面，用于将建议定向到特定的类和方法。完整的界面如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Pointcut</span> &#123;    <span class="function">ClassFilter <span class="title">getClassFilter</span>(<span class="params"></span>)</span>;    <span class="function">MethodMatcher <span class="title">getMethodMatcher</span>(<span class="params"></span>)</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>Pointcut</code>接口分为两部分，可以重用类和方法匹配的部分以及细粒度的合成操作(例如与另一个方法匹配器执行“联合”)。</p>
<p><code>ClassFilter</code>接口用于将切入点限制为给定的一组目标类。如果<code>matches()</code>方法始终返回 true，则匹配所有目标类。以下清单显示了<code>ClassFilter</code>接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFilter</span> </span>&#123;    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class clazz)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodMatcher</code>界面通常更重要。完整的界面如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method m, Class targetClass)</span></span>;    <span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method m, Class targetClass, Object[] args)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p><code>matches(Method, Class)</code>方法用于测试此切入点是否与目标类上的给定方法匹配。创建 AOP 代理时可以执行此评估，以避免需要对每个方法调用进行测试。如果给定方法的两个参数的<code>matches</code>方法返回<code>true</code>，而用于 MethodMatcher 的<code>isRuntime()</code>的方法返回<code>true</code>，则在每次方法调用时都会调用三个参数的 match 方法。这样，切入点就可以在执行目标建议之前立即查看传递给方法调用的参数。</p>
<p>大多数<code>MethodMatcher</code>实现是静态的，这意味着它们的<code>isRuntime()</code>方法返回<code>false</code>。在这种情况下，永远不会调用三参数<code>matches</code>方法。</p>
<p>Tip</p>
<p>如果可能，请尝试使切入点成为静态，从而在创建 AOP 代理时允许 AOP 框架缓存切入点评估的结果。</p>
<h4 id="6-1-2-切入点的操作"><a href="#6-1-2-切入点的操作" class="headerlink" title="6.1.2. 切入点的操作"></a>6.1.2. 切入点的操作</h4><p>Spring 支持切入点上的操作(特别是联合和相交)。</p>
<p>联合表示两个切入点都匹配的方法。交集是指两个切入点都匹配的方法。联合通常更有用。您可以使用<code>org.springframework.aop.support.Pointcuts</code>类中的静态方法或同一包中的<code>ComposablePointcut</code>类来编写切入点。但是，使用 AspectJ 切入点表达式通常是一种更简单的方法。</p>
<h4 id="6-1-3-AspectJ-表达切入点"><a href="#6-1-3-AspectJ-表达切入点" class="headerlink" title="6.1.3. AspectJ 表达切入点"></a>6.1.3. AspectJ 表达切入点</h4><p>从 2.0 开始，Spring 使用的最重要的切入点类型是<code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>。这是一个切入点，该切入点使用 AspectJ 提供的库来解析 AspectJ 切入点表达式字符串。</p>
<p>有关支持的 AspectJ 切入点 Primitives 的讨论，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">previous chapter</a>。</p>
<h4 id="6-1-4-便捷切入点实现"><a href="#6-1-4-便捷切入点实现" class="headerlink" title="6.1.4. 便捷切入点实现"></a>6.1.4. 便捷切入点实现</h4><p>Spring 提供了几种方便的切入点实现。您可以直接使用其中一些。其他的则应归入特定于应用程序的切入点中。</p>
<h5 id="Static-Pointcuts"><a href="#Static-Pointcuts" class="headerlink" title="Static Pointcuts"></a>Static Pointcuts</h5><p>静态切入点是基于方法和目标类的，不能考虑方法的参数。静态切入点足以满足大多数用途，并且最好。首次调用方法时，Spring 只能评估一次静态切入点。之后，无需在每次方法调用时再次评估切入点。</p>
<p>本节的其余部分描述了 Spring 附带的一些静态切入点实现。</p>
<h6 id="正则表达式切入点"><a href="#正则表达式切入点" class="headerlink" title="正则表达式切入点"></a>正则表达式切入点</h6><p>指定静态切入点的一种明显方法是正则表达式。除了 Spring 之外，还有几个 AOP 框架使之成为可能。 <code>org.springframework.aop.support.JdkRegexpMethodPointcut</code>是通用正则表达式切入点，它使用 JDK 中的正则表达式支持。</p>
<p>使用<code>JdkRegexpMethodPointcut</code>类，可以提供模式字符串列表。如果其中任何一个匹配，则切入点的值为<code>true</code>。 (因此，结果实际上是这些切入点的并集.)</p>
<p>以下示例显示了如何使用<code>JdkRegexpMethodPointcut</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;settersAndAbsquatulatePointcut&quot;</span>        <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;patterns&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>.*set.*<span class="tag">&lt;/<span class="name">value</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>.*absquatulate<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 提供了一个名为<code>RegexpMethodPointcutAdvisor</code>的便捷类，它使我们也可以引用<code>Advice</code>(请记住<code>Advice</code>可以是拦截器，而不是建议，引发建议等)。在后台，Spring 使用<code>JdkRegexpMethodPointcut</code>。使用<code>RegexpMethodPointcutAdvisor</code>简化了接线，因为一个 bean 封装了切入点和建议，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;settersAndAbsquatulateAdvisor&quot;</span>        <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;advice&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;beanNameOfAopAllianceInterceptor&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;patterns&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>.*set.*<span class="tag">&lt;/<span class="name">value</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>.*absquatulate<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您可以将<code>RegexpMethodPointcutAdvisor</code>与任何<code>Advice</code>类型一起使用。</p>
<h6 id="Attribute-driven-Pointcuts"><a href="#Attribute-driven-Pointcuts" class="headerlink" title="Attribute-driven Pointcuts"></a>Attribute-driven Pointcuts</h6><p>静态切入点的一种重要类型是元数据驱动的切入点。这使用元数据属性的值(通常是源级别的元数据)。</p>
<h5 id="Dynamic-pointcuts"><a href="#Dynamic-pointcuts" class="headerlink" title="Dynamic pointcuts"></a>Dynamic pointcuts</h5><p>动态切入点比静态切入点更昂贵。它们考虑了方法参数以及静态信息。这意味着必须在每次方法调用时对它们进行评估，并且由于参数会有所不同，因此无法缓存结果。</p>
<p>主要示例是<code>control flow</code>切入点。</p>
<h6 id="控制流切入点"><a href="#控制流切入点" class="headerlink" title="控制流切入点"></a>控制流切入点</h6><p>Spring 控制流切入点在概念上类似于 AspectJ <code>cflow</code>切入点，但功能较弱。 (当前无法指定一个切入点在与另一个切入点匹配的连接点下执行.)控制流切入点与当前调用堆栈匹配。例如，如果连接点是由<code>com.mycompany.web</code>包中的方法或<code>SomeCaller</code>类调用的，则可能会触发。通过使用<code>org.springframework.aop.support.ControlFlowPointcut</code>类指定控制流切入点。</p>
<p>Note</p>
<p>与其他动态切入点相比，控制流切入点在运行时进行评估要昂贵得多。在 Java 1.4 中，成本大约是其他动态切入点的五倍。</p>
<h4 id="6-1-5-切入点超类"><a href="#6-1-5-切入点超类" class="headerlink" title="6.1.5. 切入点超类"></a>6.1.5. 切入点超类</h4><p>Spring 提供了有用的切入点超类，以帮助您实现自己的切入点。</p>
<p>因为静态切入点最有用，所以您可能应该子类<code>StaticMethodMatcherPointcut</code>。这仅需要实现一个抽象方法(尽管您可以覆盖其他方法以自定义行为)。以下示例显示了如何对<code>StaticMethodMatcherPointcut</code>进行子类化：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStaticPointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> </span>&#123;    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">matches</span>(<span class="params">Method m, Class targetClass</span>)</span> &#123;        <span class="comment">// return true if custom criteria match    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>动态切入点也有超类。</p>
<p>在 Spring 1.0 RC2 及更高版本中，您可以将自定义切入点与任何建议类型一起使用。</p>
<h4 id="6-1-6-自定义切入点"><a href="#6-1-6-自定义切入点" class="headerlink" title="6.1.6. 自定义切入点"></a>6.1.6. 自定义切入点</h4><p>由于 Spring AOP 中的切入点是 Java 类，而不是语言功能(如 AspectJ)，因此可以声明自定义切入点，无论是静态还是动态。 Spring 中的自定义切入点可以任意复杂。但是，如果可以的话，我们建议使用 AspectJ 切入点表达语言。</p>
<p>Note</p>
<p>更高版本的 Spring 可能提供对 JAC offered 提供的“语义切入点”的支持，例如，“更改目标对象中实例变量的所有方法”。</p>
<h3 id="6-2-Spring-咨询-API"><a href="#6-2-Spring-咨询-API" class="headerlink" title="6.2. Spring 咨询 API"></a>6.2. Spring 咨询 API</h3><p>现在，我们可以检查 Spring AOP 如何处理建议。</p>
<h4 id="6-2-1-咨询生命周期"><a href="#6-2-1-咨询生命周期" class="headerlink" title="6.2.1. 咨询生命周期"></a>6.2.1. 咨询生命周期</h4><p>每个建议都是一个 Spring bean。建议实例可以在所有建议对象之间共享，或者对于每个建议对象都是唯一的。这对应于每个类或每个实例的建议。</p>
<p>每班建议最常用。适用于一般建议，例如 Transaction 顾问。这些不依赖于代理对象的状态或添加新状态。它们仅作用于方法和参数。</p>
<p>每个实例的建议都适合引入，以支持混合。在这种情况下，建议将状态添加到代理对象。</p>
<p>您可以在同一 AOP 代理中混合使用共享建议和基于实例的建议。</p>
<h4 id="6-2-2-Spring-的建议类型"><a href="#6-2-2-Spring-的建议类型" class="headerlink" title="6.2.2. Spring 的建议类型"></a>6.2.2. Spring 的建议类型</h4><p>Spring 提供了几种建议类型，并且可以扩展以支持任意建议类型。本节介绍基本概念和标准建议类型。</p>
<h5 id="围绕建议进行拦截"><a href="#围绕建议进行拦截" class="headerlink" title="围绕建议进行拦截"></a>围绕建议进行拦截</h5><p>Spring 中最基本的建议类型是围绕建议的拦截。</p>
<p>对于使用方法拦截的建议，Spring 符合 AOP <code>Alliance</code>接口。实现<code>MethodInterceptor</code>并围绕建议实现的类也应实现以下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;    <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code>方法的<code>MethodInvocation</code>参数公开了正在调用的方法，目标连接点，AOP 代理以及该方法的参数。 <code>invoke()</code>方法应返回调用的结果：连接点的返回值。</p>
<p>以下示例显示了一个简单的<code>MethodInterceptor</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="string">&quot;Before: invocation=[&quot;</span> + invocation + <span class="string">&quot;]&quot;</span>);        Object rval = invocation.proceed();        System.out.println(<span class="string">&quot;Invocation returned&quot;</span>);        <span class="keyword">return</span> rval;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>请注意对<code>MethodInvocation</code>的<code>proceed()</code>方法的调用。这沿着拦截器链向下到达连接点。大多数拦截器都调用此方法并返回其返回值。但是，<code>MethodInterceptor</code>就像任何周围的建议一样，可以返回不同的值或引发异常，而不是调用 proceed 方法。但是，您没有充分的理由就不想这样做。</p>
<p>Note</p>
<p><code>MethodInterceptor</code>实现提供与其他符合 AOP Alliance 要求的 AOP 实现的互操作性。本节其余部分讨论的其他建议类型将实现常见的 AOP 概念，但以特定于 Spring 的方式。尽管使用最具体的建议类型有一个优势，但是如果您可能想在另一个 AOP 框架中运行切面，请坚持使用<code>MethodInterceptor</code>。请注意，切入点当前无法在框架之间互操作，并且 AOP Alliance 当前未定义切入点接口。</p>
<h5 id="Before-Advice-2"><a href="#Before-Advice-2" class="headerlink" title="Before Advice"></a>Before Advice</h5><p>一种更简单的建议类型是事前建议。不需要<code>MethodInvocation</code>对象，因为它仅在进入方法之前被调用。</p>
<p>先行建议的主要优点是无需调用<code>proceed()</code>方法，因此，不会无意中未能沿拦截器链 continue 前进。</p>
<p>以下清单显示了<code>MethodBeforeAdvice</code>界面：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;    <span class="keyword">void</span> before(Method m, <span class="keyword">Object</span>[] args, <span class="keyword">Object</span> target) throws <span class="built_in">Throwable</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>(尽管通常的对象适用于字段拦截，并且 Spring 不太可能实现它，但 Spring 的 API 设计允许先于字段咨询.)</p>
<p>请注意，返回类型为<code>void</code>。通知可以在联接点执行之前插入自定义行为，但不能更改返回值。如果之前的建议引发异常，它将中止拦截器链的进一步执行。异常会传播回拦截器链。如果未选中它或在调用的方法的签名上，则将其直接传递给 Client 端。否则，它将被 AOP 代理包装在未经检查的异常中。</p>
<p>以下示例显示了 Spring 中的 before 建议，该建议计算所有方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> count;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method m, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;        ++count;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> count;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Tip</p>
<p>在将建议与任何切入点一起使用之前。</p>
<h5 id="Throws-Advice"><a href="#Throws-Advice" class="headerlink" title="Throws Advice"></a>Throws Advice</h5><p>如果联接点引发异常，则在联接点返回之后调用引发通知。 Spring 提供类型化的抛出建议。请注意，这意味着<code>org.springframework.aop.ThrowsAdvice</code>接口不包含任何方法。它是一个标签接口，用于标识给定对象实现了一个或多个类型化的 throws 通知方法。这些应采用以下形式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afterThrowing(<span class="selector-attr">[Method, args, target]</span>, subclassOfThrowable)</span><br></pre></td></tr></table></figure>

<p>仅最后一个参数是必需的。方法签名可以具有一个或四个参数，具体取决于建议方法是否对该方法和参数感兴趣。接下来的两个清单显示了类，它们是引发建议的示例。</p>
<p>如果抛出<code>RemoteException</code>(包括来自子类)，则调用以下建议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(RemoteException ex)</span> <span class="keyword">throws</span> Throwable </span>&#123;        <span class="comment">// Do something with remote exception    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>与前面的建议不同，下一个示例声明四个参数，以便可以访问被调用的方法，方法参数和目标对象。如果抛出<code>ServletException</code>，则调用以下建议：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletThrowsAdviceWithArguments</span> <span class="title">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">afterThrowing</span>(<span class="params">Method m, <span class="built_in">Object</span>[] args, <span class="built_in">Object</span> target, ServletException ex</span>)</span> &#123;        <span class="comment">// Do something with all arguments    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>最后一个示例说明如何在处理<code>RemoteException</code>和<code>ServletException</code>的单个类中使用这两种方法。可以将任意数量的引发建议方法组合到一个类中。以下清单显示了最后一个示例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedThrowsAdvice</span> <span class="title">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;    <span class="keyword">public</span> <span class="built_in">void</span> afterThrowing(RemoteException ex) throws Throwable &#123;        <span class="comment">// Do something with remote exception    &#125;    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) &#123;        // Do something with all arguments    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>如果 throws-advice 方法本身引发异常，则它将覆盖原始异常(也就是说，它将更改引发给用户的异常)。重写异常通常是 RuntimeException，它与任何方法签名都兼容。但是，如果 throws-advice 方法抛出一个已检查的异常，则它必须与目标方法的已声明异常匹配，因此在某种程度上与特定的目标方法签名耦合。 <em>请勿抛出与目标方法签名不兼容的未声明检查异常！</em></p>
<p>Tip</p>
<p>抛出建议可以与任何切入点一起使用。</p>
<h5 id="返回建议后-1"><a href="#返回建议后-1" class="headerlink" title="返回建议后"></a>返回建议后</h5><p>在 Spring 中返回通知后，必须实现<code>org.springframework.aop.AfterReturningAdvice</code>接口，以下清单显示了该接口：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">Advice</span> </span>&#123;    <span class="keyword">void</span> afterReturning(<span class="keyword">Object</span> returnValue, Method m, <span class="keyword">Object</span>[] args, <span class="keyword">Object</span> target)            throws <span class="built_in">Throwable</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>After After Returning 建议可以访问返回值(它不能修改)，调用的方法，方法的参数和目标。</p>
<p>返回建议后的以下内容将计数所有未引发异常的成功方法调用：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingAfterReturningAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> count;    <span class="keyword">public</span> <span class="keyword">void</span> afterReturning(<span class="keyword">Object</span> returnValue, Method m, <span class="keyword">Object</span>[] args, <span class="keyword">Object</span> target)            throws <span class="built_in">Throwable</span> &#123;        ++count;    &#125;    <span class="keyword">public</span> <span class="keyword">int</span> getCount() &#123;        <span class="keyword">return</span> count;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>该建议不会更改执行路径。如果抛出异常，则会将其抛出拦截器链，而不是返回值。</p>
<p>Tip</p>
<p>返回后，建议可以与任何切入点一起使用。</p>
<h5 id="Introduction-Advice"><a href="#Introduction-Advice" class="headerlink" title="Introduction Advice"></a>Introduction Advice</h5><p>Spring 将介绍建议视为一种特殊的拦截建议。</p>
<p>简介需要<code>IntroductionAdvisor</code>和<code>IntroductionInterceptor</code>来实现以下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntroductionInterceptor</span> <span class="keyword">extends</span> <span class="title">MethodInterceptor</span> </span>&#123;    <span class="function"><span class="keyword">boolean</span> <span class="title">implementsInterface</span><span class="params">(Class intf)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>从 AOP Alliance <code>MethodInterceptor</code>接口继承的<code>invoke()</code>方法必须实现介绍。也就是说，如果被调用的方法在引入的接口上，则引入拦截器负责处理方法调用-它不能调用<code>proceed()</code>。</p>
<p>简介建议不能与任何切入点一起使用，因为它仅适用于类，而不适用于方法级别。您只能通过<code>IntroductionAdvisor</code>使用介绍建议，该建议具有以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntroductionAdvisor</span> <span class="keyword">extends</span> <span class="title">Advisor</span>, <span class="title">IntroductionInfo</span> </span>&#123;    <span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">validateInterfaces</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException</span>;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntroductionInfo</span> </span>&#123;    Class[] getInterfaces();&#125;</span><br></pre></td></tr></table></figure>

<p>没有<code>MethodMatcher</code>，因此也没有<code>Pointcut</code>与介绍建议相关联。只有类过滤是合乎逻辑的。</p>
<p><code>getInterfaces()</code>方法返回此顾问程序引入的接口。</p>
<p>在内部使用<code>validateInterfaces()</code>方法来查看引入的接口是否可以由配置的<code>IntroductionInterceptor</code>实现。</p>
<p>考虑一下 Spring 测试套件中的一个示例，并假设我们想为一个或多个对象引入以下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lockable</span> </span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">boolean</span> <span class="title">locked</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>这说明了混合。我们希望能够将建议对象强制转换为<code>Lockable</code>，无论它们的类型如何，并调用锁定和解锁方法。如果调用<code>lock()</code>方法，则希望所有的 setter 方法都抛出<code>LockedException</code>。因此，我们可以添加一个切面，使对象在不了解对象的情况下不可变：AOP 的一个很好的例子。</p>
<p>首先，我们需要一个<code>IntroductionInterceptor</code>来完成繁重的工作。在这种情况下，我们扩展了<code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>便利类。我们可以直接实现<code>IntroductionInterceptor</code>，但是在大多数情况下最好使用<code>DelegatingIntroductionInterceptor</code>。</p>
<p><code>DelegatingIntroductionInterceptor</code>的设计宗旨是将引入的接口委派给引入接口的实际实现，从而隐藏使用拦截的方式。您可以使用构造函数参数将委托设置为任何对象。默认委托(使用无参数构造函数时)为<code>this</code>。因此，在下一个示例中，委托是<code>DelegatingIntroductionInterceptor</code>的<code>LockMixin</code>子类。给定一个委托(默认情况下为自身)，<code>DelegatingIntroductionInterceptor</code>实例将查找由委托实现的所有接口(<code>IntroductionInterceptor</code>除外)，并支持针对其中任何接口的介绍。诸如<code>LockMixin</code>之类的子类可以调用<code>suppressInterface(Class intf)</code>方法来禁止不应公开的接口。但是，无论<code>IntroductionInterceptor</code>准备支持多少个接口，<code>IntroductionAdvisor</code>使用的控件都会控制实际公开哪些接口。引入的接口隐藏了目标对同一接口的任何实现。</p>
<p>因此，<code>LockMixin</code>扩展了<code>DelegatingIntroductionInterceptor</code>并实现了<code>Lockable</code>本身。超类会自动选择支持<code>Lockable</code>进行介绍，因此我们无需指定。我们可以通过这种方式引入任意数量的接口。</p>
<p>请注意<code>locked</code>实例变量的使用。这有效地将附加状态添加到目标对象中保存的状态。</p>
<p>下面的示例显示示例<code>LockMixin</code>类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockMixin</span> <span class="keyword">extends</span> <span class="title">DelegatingIntroductionInterceptor</span> <span class="title">implements</span> <span class="title">Lockable</span> </span>&#123;    <span class="keyword">private</span> <span class="built_in">boolean</span> locked;    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">lock</span>(<span class="params"></span>)</span> &#123;        <span class="built_in">this</span>.locked = <span class="literal">true</span>;    &#125;    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">unlock</span>(<span class="params"></span>)</span> &#123;        <span class="built_in">this</span>.locked = <span class="literal">false</span>;    &#125;    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">locked</span>(<span class="params"></span>)</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.locked;    &#125;    <span class="keyword">public</span> <span class="built_in">Object</span> invoke(MethodInvocation invocation) throws Throwable &#123;        <span class="keyword">if</span> (locked() &amp;&amp; invocation.getMethod().getName().indexOf(<span class="string">&quot;set&quot;</span>) == <span class="number">0</span>) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> LockedException();        &#125;        <span class="keyword">return</span> <span class="built_in">super</span>.invoke(invocation);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>通常，您无需覆盖<code>invoke()</code>方法。通常，<code>DelegatingIntroductionInterceptor</code>实现(如果引入了<code>delegate</code>方法，则调用<code>delegate</code>方法，否则 continue 向连接点前进)。在当前情况下，我们需要添加一个检查：如果处于锁定模式，则不能调用任何 setter 方法。</p>
<p>所需的简介仅需要保存一个不同的<code>LockMixin</code>实例并指定所引入的接口(在这种情况下，只需<code>Lockable</code>)。一个更复杂的示例可能引用了引入拦截器(将被定义为原型)。在这种情况下，没有与<code>LockMixin</code>相关的配置，因此我们使用<code>new</code>创建它。以下示例显示了<code>LockMixinAdvisor</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockMixinAdvisor</span> <span class="keyword">extends</span> <span class="title">DefaultIntroductionAdvisor</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">LockMixinAdvisor</span><span class="params">()</span> </span>&#123;        <span class="keyword">super</span>(<span class="keyword">new</span> LockMixin(), Lockable.class);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以非常简单地应用此顾问程序，因为它不需要配置。 (但是，如果没有<code>IntroductionAdvisor</code>，就不可能使用<code>IntroductionInterceptor</code>.)像通常的介绍一样，顾问程序必须是按实例的，因为它是有状态的。对于每个建议对象，我们需要<code>LockMixinAdvisor</code>的不同实例，因此需要<code>LockMixin</code>。顾问程序包含建议对象状态的一部分。</p>
<p>我们可以像其他任何顾问一样，通过使用<code>Advised.addAdvisor()</code>方法或 XML 配置中的(推荐方式)以编程方式应用此顾问。下面讨论的所有代理创建选择，包括“自动代理创建器”，都可以正确处理介绍和有状态的混合。</p>
<h3 id="6-3-Spring-的-Advisor-API"><a href="#6-3-Spring-的-Advisor-API" class="headerlink" title="6.3. Spring 的 Advisor API"></a>6.3. Spring 的 Advisor API</h3><p>在 Spring 中，顾问程序是一个切面，其中仅包含与切入点表达式关联的单个建议对象。</p>
<p>除了介绍的特殊情况外，任何顾问都可以与任何建议一起使用。 <code>org.springframework.aop.support.DefaultPointcutAdvisor</code>是最常用的顾问类。可以与<code>MethodInterceptor</code>，<code>BeforeAdvice</code>或<code>ThrowsAdvice</code>一起使用。</p>
<p>可以在同一 AOP 代理中的 Spring 中混合使用顾问和建议类型。例如，您可以在一个代理配置中使用围绕建议的拦截，抛出建议以及在建议之前。 Spring 自动创建必要的拦截器链。</p>
<h3 id="6-4-使用-ProxyFactoryBean-创建-AOP-代理"><a href="#6-4-使用-ProxyFactoryBean-创建-AOP-代理" class="headerlink" title="6.4. 使用 ProxyFactoryBean 创建 AOP 代理"></a>6.4. 使用 ProxyFactoryBean 创建 AOP 代理</h3><p>如果将 Spring IoC 容器(<code>ApplicationContext</code>或<code>BeanFactory</code>)用于业务对象(应该是！)，则要使用 Spring 的 AOP <code>FactoryBean</code>实现之一。 (请记住，工厂 bean 引入了一个间接层，允许它创建不同类型的对象.)</p>
<p>Note</p>
<p>Spring AOP 支持还在后台使用了工厂 bean。</p>
<p>在 Spring 中创建 AOP 代理的基本方法是使用<code>org.springframework.aop.framework.ProxyFactoryBean</code>。这样可以完全控制切入点，任何适用的建议及其 Sequences。但是，如果您不需要这样的控制，则有一些更简单的选项是可取的。</p>
<h4 id="6-4-1-Basics"><a href="#6-4-1-Basics" class="headerlink" title="6.4.1. Basics"></a>6.4.1. Basics</h4><p>像其他 Spring <code>FactoryBean</code>实现一样，<code>ProxyFactoryBean</code>引入了一个间接级别。如果定义一个名为<code>foo</code>的<code>ProxyFactoryBean</code>，则引用<code>foo</code>的对象看不到<code>ProxyFactoryBean</code>实例本身，而是看到通过<code>ProxyFactoryBean</code>中的<code>getObject()</code>方法的实现创建的对象。此方法创建一个包装目标对象的 AOP 代理。</p>
<p>使用<code>ProxyFactoryBean</code>或另一个 IoC 感知类创建 AOP 代理的最重要好处之一是，IoC 也可以 Management 建议和切入点。这是一项强大的功能，可实现某些其他 AOP 框架难以实现的方法。例如，受益于依赖注入提供的所有可插入性，建议本身可以引用应用程序对象(目标之外，目标应该在任何 AOP 框架中可用)。</p>
<h4 id="6-4-2-JavaBean-属性"><a href="#6-4-2-JavaBean-属性" class="headerlink" title="6.4.2. JavaBean 属性"></a>6.4.2. JavaBean 属性</h4><p>与 Spring 提供的大多数<code>FactoryBean</code>实现一样，<code>ProxyFactoryBean</code>类本身就是 JavaBean。其属性用于：</p>
<ul>
<li>指定您要代理的目标。</li>
<li>指定是否使用 CGLIB(稍后介绍，另请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-pfb-proxy-types">基于 JDK 和 CGLIB 的代理</a>)。</li>
</ul>
<p>一些关键属性是从<code>org.springframework.aop.framework.ProxyConfig</code>(Spring 中所有 AOP 代理工厂的超类)继承的。这些关键属性包括：</p>
<ul>
<li><code>proxyTargetClass</code>：<code>true</code>(如果要代理目标类，而不是目标类的接口)。如果此属性值设置为<code>true</code>，那么将创建 CGLIB 代理(但也请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-pfb-proxy-types">基于 JDK 和 CGLIB 的代理</a>)。</li>
<li><code>optimize</code>：控制是否将积极的优化应用于通过 CGLIB 创建的代理。除非您完全了解相关的 AOP 代理如何处理优化，否则不要随意使用此设置。当前仅用于 CGLIB 代理。它对 JDK 动态代理无效。</li>
<li><code>frozen</code>：如果代理配置为<code>frozen</code>，则不再允许更改配置。这是一个轻微的优化，对于在您不希望调用者在创建代理后能够(通过<code>Advised</code>接口)操纵代理的情况下很有用。此属性的默认值为<code>false</code>，因此允许进行更改(例如添加其他建议)。</li>
<li><code>exposeProxy</code>：确定是否应在<code>ThreadLocal</code>中公开当前代理，以便目标可以访问它。如果目标需要获取代理并且<code>exposeProxy</code>属性设置为<code>true</code>，则目标可以使用<code>AopContext.currentProxy()</code>方法。</li>
</ul>
<p><code>ProxyFactoryBean</code>特有的其他属性包括：</p>
<ul>
<li><code>proxyInterfaces</code>：<code>String</code>接口名称的数组。如果未提供，则使用目标类的 CGLIB 代理(另请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-pfb-proxy-types">基于 JDK 和 CGLIB 的代理</a>)。</li>
<li><code>interceptorNames</code>：要应用的<code>Advisor</code>，拦截器或其他建议名称的<code>String</code>数组。Sequences 很重要，先到先得。也就是说，列表中的第一个拦截器是第一个能够拦截调用的拦截器。</li>
</ul>
<p>名称是当前工厂中的 bean 名称，包括祖先工厂中的 bean 名称。您不能在这里提及 bean 引用，因为这样做会导致<code>ProxyFactoryBean</code>忽略建议的单例设置。</p>
<p>您可以在拦截器名称后加上星号(<code>*</code>)。这样做会导致应用所有顾问 Bean，其名称以要应用星号的部分开头。您可以在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-global-advisors">使用“全局”顾问</a>中找到使用此功能的示例。</p>
<ul>
<li>单例：无论调用<code>getObject()</code>方法的频率如何，工厂是否应返回单个对象。几种<code>FactoryBean</code>实现提供了这种方法。默认值为<code>true</code>。如果要使用状态通知(例如，对于状态混合)，请使用原型建议以及<code>false</code>的单例值。</li>
</ul>
<h4 id="6-4-3-基于-JDK-和-CGLIB-的代理"><a href="#6-4-3-基于-JDK-和-CGLIB-的代理" class="headerlink" title="6.4.3. 基于 JDK 和 CGLIB 的代理"></a>6.4.3. 基于 JDK 和 CGLIB 的代理</h4><p>本部分是有关<code>ProxyFactoryBean</code>如何选择为特定目标对象(将被代理)创建基于 JDK 的代理或基于 CGLIB 的代理的 Authority 性文档。</p>
<p>Note</p>
<p>在 Spring 的 1.2.x 版和 2.0 版之间，<code>ProxyFactoryBean</code>创建基于 JDK 或 CGLIB 的代理的行为发生了变化。 <code>ProxyFactoryBean</code>现在在自动检测接口切面表现出与<code>TransactionProxyFactoryBean</code>类类似的语义。</p>
<p>如果要代理的目标对象的类(以下简称为目标类)没有实现任何接口，则将创建基于 CGLIB 的代理。这是最简单的情况，因为 JDK 代理是基于接口的，并且没有接口意味着甚至无法进行 JDK 代理。您可以插入目标 bean 并通过设置<code>interceptorNames</code>属性来指定拦截器列表。请注意，即使<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code>属性已设置为<code>false</code>，也会创建基于 CGLIB 的代理。 (这样做没有任何意义，最好将其从 Bean 定义中删除，因为它充其量是多余的，并且在最糟的情况下会造成混淆.)</p>
<p>如果目标类实现一个(或多个)接口，则创建的代理类型取决于<code>ProxyFactoryBean</code>的配置。</p>
<p>如果<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code>属性已设置为<code>true</code>，则会创建基于 CGLIB 的代理。这是有道理的，并且符合最小惊讶原则。即使已将<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code>属性设置为一个或多个完全限定的接口名称，但<code>proxyTargetClass</code>属性设置为<code>true</code>的事实也会导致基于 CGLIB 的代理生效。</p>
<p>如果<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code>属性已设置为一个或多个完全限定的接口名称，则将创建基于 JDK 的代理。创建的代理实现<code>proxyInterfaces</code>属性中指定的所有接口。如果目标类恰好实现了比<code>proxyInterfaces</code>属性中指定的接口更多的接口，那就很好了，但是这些附加接口不会由返回的代理实现。</p>
<p>如果尚未设置<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code>属性，但是目标类确实实现了一个(或多个)接口，则<code>ProxyFactoryBean</code>自动检测到目标类实际上确实实现了至少一个接口以及基于 JDK 的代理被构建。实际代理的接口是目标类实现的所有接口。实际上，这与向<code>proxyInterfaces</code>属性提供目标类实现的每个接口的列表相同。但是，它的工作量大大减少，而且不容易出现印刷错误。</p>
<h4 id="6-4-4-代理接口"><a href="#6-4-4-代理接口" class="headerlink" title="6.4.4. 代理接口"></a>6.4.4. 代理接口</h4><p>考虑一个实际的<code>ProxyFactoryBean</code>的简单示例。此示例涉及：</p>
<ul>
<li>代理的目标 bean。这是示例中的<code>personTarget</code> bean 定义。</li>
<li><code>Advisor</code>和<code>Interceptor</code>用于提供建议。</li>
<li>一个 AOP 代理 bean 定义，用于指定目标对象(<code>personTarget</code> bean)，代理接口以及要应用的建议。</li>
</ul>
<p>以下清单显示了示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personTarget&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.PersonImpl&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tony&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;51&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvisor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.MyAdvisor&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Custom string property value&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;debugInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span>    <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;proxyInterfaces&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mycompany.Person&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;personTarget&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>myAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>debugInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>interceptorNames</code>属性具有<code>String</code>列表，其中包含当前工厂中的拦截器或顾问程序的 Bean 名称。您可以在返回之前，之后使用顾问程序，拦截器并引发建议对象。顾问的 Sequences 很重要。</p>
<p>Note</p>
<p>您可能想知道为什么列表不包含 bean 引用。这样做的原因是，如果<code>ProxyFactoryBean</code>的 singleton 属性设置为<code>false</code>，则它必须能够返回独立的代理实例。如果任何顾问本身就是原型，则需要返回一个独立的实例，因此必须能够从工厂获得原型的实例。保持引用是不够的。</p>
<p>可以使用前面显示的<code>person</code> bean 定义代替<code>Person</code>实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = (Person) factory.getBean(<span class="string">&quot;person&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>与普通 Java 对象一样，在同一 IoC 上下文中的其他 bean 可以表达对此的强类型依赖性。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.PersonUser&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;person&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>PersonUser</code>类公开了<code>Person</code>类型的属性。就其而言，可以透明地使用 AOP 代理代替“真实的”人实现。但是，其类将是动态代理类。可以将其强制转换为<code>Advised</code>接口(稍后讨论)。</p>
<p>您可以使用匿名内部 bean 隐藏目标和代理之间的区别。只有<code>ProxyFactoryBean</code>定义不同。该建议仅出于完整性考虑。以下示例显示如何使用匿名内部 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvisor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.MyAdvisor&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Custom string property value&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;debugInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;proxyInterfaces&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mycompany.Person&quot;</span>/&gt;</span>    <span class="comment">&lt;!-- Use inner bean, not local reference to target --&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.PersonImpl&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tony&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;51&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>myAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>debugInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用匿名内部 bean 的优点是只有一个类型为<code>Person</code>的对象。如果我们希望防止应用程序上下文的用户获取对未建议对象的引用，或者需要避免使用 Spring IoC 自动装配的任何歧义，这将非常有用。可以说，还有一个优点是<code>ProxyFactoryBean</code>定义是独立的。但是，有时能够从工厂获得未经建议的目标实际上可能是一个优势(例如，在某些测试方案中)。</p>
<h4 id="6-4-5-代理类"><a href="#6-4-5-代理类" class="headerlink" title="6.4.5. 代理类"></a>6.4.5. 代理类</h4><p>如果您需要代理一类，而不是一个或多个接口，该怎么办？</p>
<p>想象一下，在我们之前的示例中，没有<code>Person</code>接口。我们需要建议一个名为<code>Person</code>的类，该类未实现任何业务接口。在这种情况下，您可以将 Spring 配置为使用 CGLIB 代理而不是动态代理。为此，请将前面显示的<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code>属性设置为<code>true</code>。尽管最好对接口而不是对类进行编程，但是在处理遗留代码时，建议未实现接口的类的功能可能会很有用。 (通常，Spring 并不是规定性的.虽然可以轻松地应用良好实践，但可以避免强制采用特定方法.)</p>
<p>如果需要，即使您有接口，也可以在任何情况下强制使用 CGLIB。</p>
<p>CGLIB 代理通过在运行时生成目标类的子类来工作。 Spring 配置此生成的子类以将方法调用委托给原始目标。子类用于实现 Decorator 模式，并编织在建议中。</p>
<p>CGLIB 代理通常应对用户透明。但是，有一些问题要考虑：</p>
<ul>
<li>不能建议<code>Final</code>方法，因为它们不能被覆盖。</li>
<li>无需将 CGLIB 添加到您的 Classpath 中。从 Spring 3.2 开始，CGLIB 被重新打包并包含在 spring-core JAR 中。换句话说，基于 CGLIB 的 AOP 就像 JDK 动态代理一样“开箱即用”。</li>
</ul>
<p>CGLIB 代理和动态代理之间几乎没有性能差异。从 Spring 1.0 开始，动态代理要快一些。但是，将来可能会改变。在这种情况下，性能不应作为决定性的考虑因素。</p>
<h4 id="6-4-6-使用“全局”顾问"><a href="#6-4-6-使用“全局”顾问" class="headerlink" title="6.4.6. 使用“全局”顾问"></a>6.4.6. 使用“全局”顾问</h4><p>通过在拦截器名称后附加一个星号，所有具有与该星号之前的部分匹配的 Bean 名称的顾问程序都将添加到顾问程序链中。如果您需要添加标准的“全局”顾问程序集，这可能会派上用场。以下示例定义了两个全局顾问程序：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;proxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;service&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>global*<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;global_debug&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;global_performance&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.interceptor.PerformanceMonitorInterceptor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5-简洁的代理定义"><a href="#6-5-简洁的代理定义" class="headerlink" title="6.5. 简洁的代理定义"></a>6.5. 简洁的代理定义</h3><p>特别是在定义事务代理时，您可能会得到许多类似的代理定义。使用父子 bean 定义和子 bean 定义以及内部 bean 定义可以使代理定义更加简洁明了。</p>
<p>首先，我们为代理创建父模板，bean 定义，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txProxyTemplate&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>        <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionAttributes&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">props</span>&gt;</span>            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>        <span class="tag">&lt;/<span class="name">props</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它本身从未实例化，因此实际上可能是不完整的。然后，每个需要创建的代理都是一个子 bean 定义，它将代理的目标包装为内部 bean 定义，因为无论如何该目标都不会单独使用。以下示例显示了这样的子 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myService&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;txProxyTemplate&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.MyServiceImpl&quot;</span>&gt;</span>        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您可以从父模板覆盖属性。在以下示例中，我们将覆盖事务传播设置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySpecialService&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;txProxyTemplate&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.MySpecialServiceImpl&quot;</span>&gt;</span>        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionAttributes&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">props</span>&gt;</span>            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;get*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;find*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;load*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;store*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>        <span class="tag">&lt;/<span class="name">props</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，在父 bean 的示例中，我们通过将<code>abstract</code>属性设置为<code>true</code>来明确标记父 bean 定义为抽象，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">previously</a>所述，因此它实际上可能没有实例化。默认情况下，应用程序上下文(但不是简单的 bean 工厂)会预先实例化所有单例。因此，重要的是(至少对于单例 bean)，如果您有一个(父)bean 定义仅打算用作模板，并且此定义指定了一个类，则必须确保将<code>abstract</code>属性设置为<code>true</code>。否则，应用程序上下文实际上会尝试对其进行实例化。</p>
<h3 id="6-6-使用-ProxyFactory-以编程方式创建-AOP-代理"><a href="#6-6-使用-ProxyFactory-以编程方式创建-AOP-代理" class="headerlink" title="6.6. 使用 ProxyFactory 以编程方式创建 AOP 代理"></a>6.6. 使用 ProxyFactory 以编程方式创建 AOP 代理</h3><p>使用 Spring 以编程方式创建 AOP 代理很容易。这使您可以使用 Spring AOP，而无需依赖 Spring IoC。</p>
<p>由目标对象实现的接口将被自动代理。以下清单显示了使用一个拦截器和一个顾问程序为目标对象创建代理的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(myBusinessInterfaceImpl);factory.addAdvice(myMethodInterceptor);factory.addAdvisor(myAdvisor);MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</span><br></pre></td></tr></table></figure>

<p>第一步是构造类型为<code>org.springframework.aop.framework.ProxyFactory</code>的对象。您可以使用目标对象创建此对象，如前面的示例中所示，或指定要在备用构造函数中代理的接口。</p>
<p>您可以添加建议(使用拦截器作为一种特殊的建议)，建议程序，或同时添加两者，并在<code>ProxyFactory</code>的生命周期内对其进行操作。如果添加<code>IntroductionInterceptionAroundAdvisor</code>，则可以使代理实现其他接口。</p>
<p><code>ProxyFactory</code>(从<code>AdvisedSupport</code>继承)上还有便捷的方法，可让您添加其他建议类型，例如 before 并引发建议。 <code>AdvisedSupport</code>是<code>ProxyFactory</code>和<code>ProxyFactoryBean</code>的超类。</p>
<p>Tip</p>
<p>在大多数应用程序中，将 AOP 代理创建与 IoC 框架集成在一起是最佳实践。通常，建议您使用 AOP 从 Java 代码外部化配置。</p>
<h3 id="6-7-操作建议对象"><a href="#6-7-操作建议对象" class="headerlink" title="6.7. 操作建议对象"></a>6.7. 操作建议对象</h3><p>无论创建 AOP 代理，都可以使用<code>org.springframework.aop.framework.Advised</code>界面对其进行操作。任何 AOP 代理都可以强制转换为该接口，无论它实现了哪个其他接口。该界面包括以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Advisor[] getAdvisors();<span class="function"><span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span> <span class="keyword">throws</span> AopConfigException</span>;<span class="function"><span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(<span class="keyword">int</span> pos, Advice advice)</span> <span class="keyword">throws</span> AopConfigException</span>;<span class="function"><span class="keyword">void</span> <span class="title">addAdvisor</span><span class="params">(Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException</span>;<span class="function"><span class="keyword">void</span> <span class="title">addAdvisor</span><span class="params">(<span class="keyword">int</span> pos, Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException</span>;<span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Advisor advisor)</span></span>;<span class="function"><span class="keyword">boolean</span> <span class="title">removeAdvisor</span><span class="params">(Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException</span>;<span class="function"><span class="keyword">void</span> <span class="title">removeAdvisor</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> AopConfigException</span>;<span class="function"><span class="keyword">boolean</span> <span class="title">replaceAdvisor</span><span class="params">(Advisor a, Advisor b)</span> <span class="keyword">throws</span> AopConfigException</span>;<span class="function"><span class="keyword">boolean</span> <span class="title">isFrozen</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>getAdvisors()</code>方法针对已添加到工厂的每个顾问程序，拦截器或其他建议类型返回<code>Advisor</code>。如果添加了<code>Advisor</code>，则在此索引处返回的顾问程序就是您添加的对象。如果添加了拦截器或其他建议类型，Spring 会将其包装在带有指向始终返回<code>true</code>的切入点的顾问程序中。因此，如果添加了<code>MethodInterceptor</code>，则为此索引返回的顾问程序是<code>DefaultPointcutAdvisor</code>，它返回<code>MethodInterceptor</code>以及与所有类和方法匹配的切入点。</p>
<p><code>addAdvisor()</code>方法可用于添加任何<code>Advisor</code>。通常，拥有切入点和建议的顾问是通用的<code>DefaultPointcutAdvisor</code>，您可以将其与任何建议或切入点一起使用(但不能用于介绍)。</p>
<p>默认情况下，即使已创建代理，也可以添加或删除顾问程序或拦截器。唯一的限制是不可能添加或删除介绍顾问，因为工厂中的现有代理不会显示界面更改。 (您可以从工厂获取新的代理来避免此问题.)</p>
<p>以下示例显示了将 AOP 代理投射到<code>Advised</code>接口并检查和处理其建议：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Advised advised = (Advised) myObject;Advisor[] advisors = advised.getAdvisors();<span class="built_in">int</span> oldAdvisorCount = advisors.length;System.<span class="keyword">out</span>.println(oldAdvisorCount + <span class="string">&quot; advisors&quot;</span>);<span class="comment">// Add an advice like an interceptor without a pointcut// Will match all proxied methods// Can use for interceptors, before, after returning or throws adviceadvised.addAdvice(new DebugInterceptor());// Add selective advice using a pointcutadvised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));assertEquals(&quot;Added two advisors&quot;, oldAdvisorCount + 2, advised.getAdvisors().length);</span></span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>尽管无疑存在合法的使用案例，但是否建议(无双关语)修改 Producing 的业务对象的建议值得怀疑。但是，它在开发中(例如在测试中)非常有用。有时我们发现以拦截器或其他建议的形式添加测试代码，并进入我们要测试的方法调用中非常有用。 (例如，建议可以进入为该方法创建的事务内部，也许可以在将事务标记为回滚之前运行 SQL 以检查数据库是否已正确更新.)</p>
<p>根据创建代理的方式，通常可以设置<code>frozen</code>标志。在这种情况下，<code>Advised</code> <code>isFrozen()</code>方法返回<code>true</code>，而通过添加或删除来修改建议的任何尝试都将导致<code>AopConfigException</code>。冻结建议对象状态的功能在某些情况下很有用(例如，防止调用代码删除安全拦截器)。如果已知不需要修改运行时建议，则在 Spring 1.1 中也可以使用它来进行积极的优化。</p>
<h3 id="6-8-使用“自动代理”功能"><a href="#6-8-使用“自动代理”功能" class="headerlink" title="6.8. 使用“自动代理”功能"></a>6.8. 使用“自动代理”功能</h3><p>到目前为止，我们已经考虑过使用<code>ProxyFactoryBean</code>或类似的工厂 bean 来显式创建 AOP 代理。</p>
<p>Spring 还允许我们使用“自动代理” Bean 定义，该定义可以自动代理选定的 Bean 定义。这是在 Spring 的“ bean 后处理器”基础结构上构建的，该基础结构允许在容器加载时修改任何 bean 定义。</p>
<p>在此模型中，您在 XML bean 定义文件中设置了一些特殊的 bean 定义，以配置自动代理基础结构。这使您可以声明有资格进行自动代理的目标。您无需使用<code>ProxyFactoryBean</code>。</p>
<p>有两种方法可以做到这一点：</p>
<ul>
<li>通过使用在当前上下文中引用特定 bean 的自动代理创建器。</li>
<li>自动代理创建的一种特殊情况，值得单独考虑：由源级元数据属性驱动的自动代理创建。</li>
</ul>
<h4 id="6-8-1-自动代理-Bean-定义"><a href="#6-8-1-自动代理-Bean-定义" class="headerlink" title="6.8.1. 自动代理 Bean 定义"></a>6.8.1. 自动代理 Bean 定义</h4><p>本节介绍了<code>org.springframework.aop.framework.autoproxy</code>软件包提供的自动代理创建者。</p>
<h5 id="BeanNameAutoProxyCreator"><a href="#BeanNameAutoProxyCreator" class="headerlink" title="BeanNameAutoProxyCreator"></a>BeanNameAutoProxyCreator</h5><p><code>BeanNameAutoProxyCreator</code>类是<code>BeanPostProcessor</code>，它会自动为名称与 Literals 值或通配符匹配的 bean 创建 AOP 代理。以下示例显示了如何创建<code>BeanNameAutoProxyCreator</code> bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdk*,onlyJdk&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>myInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与<code>ProxyFactoryBean</code>一样，有<code>interceptorNames</code>属性而不是拦截器列表，以允许原型顾问程序具有正确的行为。命名为“拦截器”的可以是顾问或任何建议类型。</p>
<p>通常，与自动代理一样，使用<code>BeanNameAutoProxyCreator</code>的要点是将相同的配置一致地应用于多个对象，并且配置量最少。将声明式事务应用于多个对象是一种流行的选择。</p>
<p>名称匹配的 Bean 定义(例如上例中的<code>jdkMyBean</code>和<code>onlyJdk</code>)是带有目标类的普通旧 Bean 定义。 <code>BeanNameAutoProxyCreator</code>自动创建一个 AOP 代理。相同的建议适用于所有匹配的 bean。注意，如果使用了顾问程序(而不是前面示例中的拦截器)，则切入点可能会不同地应用于不同的 bean。</p>
<h5 id="DefaultAdvisorAutoProxyCreator"><a href="#DefaultAdvisorAutoProxyCreator" class="headerlink" title="DefaultAdvisorAutoProxyCreator"></a>DefaultAdvisorAutoProxyCreator</h5><p>一个更通用，功能更强大的自动代理创建者是<code>DefaultAdvisorAutoProxyCreator</code>。这可以在当前上下文中自动应用合格的顾问程序，而无需在自动代理顾问程序的 Bean 定义中包括特定的 Bean 名称。它具有与<code>BeanNameAutoProxyCreator</code>相同的一致配置和避免重复的优点。</p>
<p>使用此机制涉及：</p>
<ul>
<li>指定<code>DefaultAdvisorAutoProxyCreator</code> bean 定义。</li>
<li>在相同或相关的上下文中指定任意数量的顾问。请注意，这些必须是顾问，而不是拦截器或其他建议。这是必要的，因为必须有一个评估的切入点，以检查每个建议是否符合候选 bean 定义。</li>
</ul>
<p><code>DefaultAdvisorAutoProxyCreator</code>自动评估每个顾问中包含的切入点，以查看它应应用于每个业务对象的建议(如果有)(例如示例中的<code>businessObject1</code>和<code>businessObject2</code>)。</p>
<p>这意味着可以将任意数量的顾问程序自动应用于每个业务对象。如果在任何顾问程序中没有切入点与业务对象中的任何方法匹配，则该对象不会被代理。当为新的业务对象添加 Bean 定义时，如有必要，它们会自动被代理。</p>
<p>通常，自动代理的优点是使调用者或依赖者无法获得不建议的对象。在此<code>ApplicationContext</code>上调用<code>getBean(&quot;businessObject1&quot;)</code>将返回 AOP 代理，而不是目标业务对象。 (前面显示的“ inner bean”惯用语也提供了这一好处.)</p>
<p>以下示例创建一个<code>DefaultAdvisorAutoProxyCreator</code> bean 和本节中讨论的其他元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span>/&gt;<span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionInterceptor&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;transactionInterceptor&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customAdvisor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.MyAdvisor&quot;</span>/&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;businessObject1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.BusinessObject1&quot;</span>&gt;</span>    <span class="comment">&lt;!-- Properties omitted --&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;businessObject2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.BusinessObject2&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果要将相同的建议一致地应用于许多业务对象，则<code>DefaultAdvisorAutoProxyCreator</code>非常有用。基础结构定义到位后，您可以添加新的业务对象，而无需包括特定的代理配置。您还可以轻松地添加其他切面(例如，跟踪或性能监视切面)，而对配置的更改最少。</p>
<p><code>DefaultAdvisorAutoProxyCreator</code>支持过滤(通过使用命名约定，以便仅评估某些顾问程序，从而允许在同一工厂中使用多个不同配置的 AdvisorAutoProxyCreators)和排序。如果存在问题，顾问可以实现<code>org.springframework.core.Ordered</code>接口以确保正确的排序。前面示例中使用的<code>TransactionAttributeSourceAdvisor</code>具有可配置的 Sequences 值。默认设置为无序。</p>
<h3 id="6-9-使用-TargetSource-实现"><a href="#6-9-使用-TargetSource-实现" class="headerlink" title="6.9. 使用 TargetSource 实现"></a>6.9. 使用 TargetSource 实现</h3><p>Spring 提供了<code>org.springframework.aop.TargetSource</code>接口中表示的<code>TargetSource</code>的概念。该接口负责返回实现连接点的“目标对象”。每次 AOP 代理处理方法调用时，都会向<code>TargetSource</code>实现请求目标实例。</p>
<p>使用 Spring AOP 的开发人员通常不需要直接使用<code>TargetSource</code>实现，但这提供了支持池化，热插拔和其他复杂目标的强大方法。例如，池<code>TargetSource</code>可以通过使用池来 Management 实例，从而为每次调用返回不同的目标实例。</p>
<p>如果未指定<code>TargetSource</code>，则使用默认实现包装本地对象。每次调用都会返回相同的目标(与您期望的一样)。</p>
<p>本节的其余部分描述了 Spring 随附的标准目标源以及如何使用它们。</p>
<p>Tip</p>
<p>使用自定义目标源时，目标通常需要是原型而不是单例 bean 定义。这样，Spring 可以在需要时创建一个新的目标实例。</p>
<h4 id="6-9-1-可热交换的目标源"><a href="#6-9-1-可热交换的目标源" class="headerlink" title="6.9.1. 可热交换的目标源"></a>6.9.1. 可热交换的目标源</h4><p><code>org.springframework.aop.target.HotSwappableTargetSource</code>的存在是为了允许 AOP 代理服务器的目标切换，同时允许呼叫者保留对其的引用。</p>
<p>更改目标源的目标会立即生效。 <code>HotSwappableTargetSource</code>是线程安全的。</p>
<p>您可以使用 HotSwappableTargetSource 上的<code>swap()</code>方法更改目标，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean(<span class="string">&quot;swapper&quot;</span>);</span><br><span class="line">Object oldTarget = swapper.swap(newTarget);</span><br></pre></td></tr></table></figure>

<p>以下示例显示了必需的 XML 定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;initialTarget&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;mycompany.OldTarget&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;swapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.target.HotSwappableTargetSource&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;initialTarget&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;swappable&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;swapper&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>前面的<code>swap()</code>调用更改了可交换 bean 的目标。拥有对该 bean 的引用的 Client 端不知道更改，但立即开始达到新目标。</p>
<p>尽管此示例未添加任何建议(使用<code>TargetSource</code>无需添加建议)，但任何<code>TargetSource</code>均可与任意建议结合使用。</p>
<h4 id="6-9-2-汇集目标源"><a href="#6-9-2-汇集目标源" class="headerlink" title="6.9.2. 汇集目标源"></a>6.9.2. 汇集目标源</h4><p>使用池目标源提供了与 Stateless 会话 EJB 相似的编程模型，在 Stateless 会话 EJB 中，维护了相同实例的池，方法调用将释放池中的对象。</p>
<p>Spring 池和 SLSB 池之间的关键区别在于，Spring 池可以应用于任何 POJO。通常，与 Spring 一样，可以以非侵入性方式应用此服务。</p>
<p>Spring 提供了对 Commons Pool 2.2 的支持，该池提供了相当有效的池实现。您需要在应用程序的 Classpath 上使用<code>commons-pool</code> Jar 才能使用此功能。您还可以将<code>org.springframework.aop.target.AbstractPoolingTargetSource</code>子类化以支持任何其他池化 API。</p>
<p>Note</p>
<p>还支持 Commons Pool 1.5，但从 Spring Framework 4.2 开始不推荐使用。</p>
<p>以下清单显示了一个示例配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;businessObjectTarget&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mycompany.MyBusinessObject&quot;</span>        <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span>    ... properties omitted<span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;poolTargetSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.target.CommonsPool2TargetSource&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;businessObjectTarget&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;businessObject&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;poolTargetSource&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;myInterceptor&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，目标对象(上例中为<code>businessObjectTarget</code>)必须是原型。这使<code>PoolingTargetSource</code>实现可以创建目标的新实例以根据需要扩展池。有关其属性的信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html">AbstractPoolingTargetSource 的 javadoc</a>和您希望使用的具体子类。 <code>maxSize</code>是最基本的，并且始终保证存在。</p>
<p>在这种情况下，<code>myInterceptor</code>是需要在同一 IoC 上下文中定义的拦截器的名称。但是，您无需指定拦截器即可使用池。如果只希望池化而没有其他建议，则根本不要设置<code>interceptorNames</code>属性。</p>
<p>您可以将 Spring 配置为能够将任何池化对象投射到<code>org.springframework.aop.target.PoolingConfig</code>接口，该接口通过介绍来公开有关池的配置和当前大小的信息。您需要定义类似于以下内容的顾问程序：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;poolConfigAdvisor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetObject&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;poolTargetSource&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetMethod&quot;</span> <span class="attr">value</span>=<span class="string">&quot;getPoolingConfigMixin&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过在<code>AbstractPoolingTargetSource</code>类上调用便捷方法(因此使用<code>MethodInvokingFactoryBean</code>)可获得此顾问程序。该顾问的名称(此处为<code>poolConfigAdvisor</code>)必须位于公开池对象的<code>ProxyFactoryBean</code>中的拦截器名称列表中。</p>
<p>演员表的定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PoolingConfig conf = (PoolingConfig) beanFactory.getBean(<span class="string">&quot;businessObject&quot;</span>);System.<span class="keyword">out</span>.println(<span class="string">&quot;Max pool size is &quot;</span> + conf.getMaxSize());</span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>通常不需要合并 Stateless 服务对象。我们不认为它应该是默认选择，因为大多数 Stateless 对象自然是线程安全的，并且如果缓存了资源，实例池会成问题。</p>
<p>通过使用自动代理，可以简化池。您可以设置任何自动代理创建者使用的<code>TargetSource</code>实现。</p>
<h4 id="6-9-3-原型目标源"><a href="#6-9-3-原型目标源" class="headerlink" title="6.9.3. 原型目标源"></a>6.9.3. 原型目标源</h4><p>设置“原型”目标源类似于设置池<code>TargetSource</code>。在这种情况下，每次方法调用都会创建目标的新实例。尽管在现代 JVM 中创建新对象的成本并不高，但是连接新对象(满足其 IoC 依赖关系)的成本可能会更高。因此，没有充分的理由就不应使用此方法。</p>
<p>为此，您可以按如下所示修改<code>poolTargetSource</code>定义(为清楚起见，我们也更改了名称)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;prototypeTargetSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.target.PrototypeTargetSource&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetBeanName&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;businessObjectTarget&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>唯一的属性是目标 Bean 的名称。 <code>TargetSource</code>实现中使用继承来确保命名的一致性。与池化目标源一样，目标 Bean 必须是原型 Bean 定义。</p>
<h4 id="6-9-4-ThreadLocal-目标源"><a href="#6-9-4-ThreadLocal-目标源" class="headerlink" title="6.9.4. ThreadLocal 目标源"></a>6.9.4. ThreadLocal 目标源</h4><p>如果您需要为每个传入请求(每个线程)创建一个对象，则<code>ThreadLocal</code>目标源很有用。 <code>ThreadLocal</code>的概念提供了 JDK 范围的功能，可以透明地将资源与线程一起存储。设置<code>ThreadLocalTargetSource</code>与其他类型的目标源所说明的几乎相同，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;threadlocalTargetSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.target.ThreadLocalTargetSource&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;businessObjectTarget&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Note</p>
<p><code>ThreadLocal</code>实例在多线程和多类加载器环境中使用不正确时会遇到严重问题(可能导致内存泄漏)。您应该始终考虑将 threadlocal 包装在其他一些类中，并且切勿直接使用<code>ThreadLocal</code>本身(包装类中除外)。另外，您应始终记住正确设置和取消设置线程本地资源(在后者中仅涉及对<code>ThreadLocal.set(null)</code>的调用)。在任何情况下都应进行取消设置，因为不取消设置可能会导致出现问题。 Spring 的<code>ThreadLocal</code>支持为您做到了这一点，应该始终考虑使用<code>ThreadLocal</code>实例，而无需其他适当的处理代码。</p>
<h3 id="6-10-定义新的建议类型"><a href="#6-10-定义新的建议类型" class="headerlink" title="6.10. 定义新的建议类型"></a>6.10. 定义新的建议类型</h3><p>Spring AOP 被设计为可扩展的。尽管目前在内部使用拦截实现策略，但是除了在建议周围，在建议之前，抛出建议和返回建议之后进行拦截之外，还可以支持任意建议类型。</p>
<p><code>org.springframework.aop.framework.adapter</code>软件包是 SPI 软件包，可在不更改核心框架的情况下添加对新的自定义建议类型的支持。自定义<code>Advice</code>类型的唯一限制是它必须实现<code>org.aopalliance.aop.Advice</code>标记接口。</p>
<p>有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html">org.springframework.aop.framework.adapter</a> javadoc。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/spring/" rel="tag"># spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/22/blog/%E5%A4%9A%E7%BB%88%E7%AB%AF%E7%BC%96%E8%BE%91/" rel="prev" title="多终端编辑">
      <i class="fa fa-chevron-left"></i> 多终端编辑
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/22/Java/spring/Spring-overview/" rel="next" title="spring-overview">
      spring-overview <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">AOP 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringAOP-%E8%83%BD%E5%8A%9B%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="nav-number">2.</span> <span class="nav-text">SpringAOP 能力和目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP-%E4%BB%A3%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">AOP 代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AspectJ-%E6%94%AF%E6%8C%81"><span class="nav-number">4.</span> <span class="nav-text">@AspectJ 支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8-AspectJ-%E6%94%AF%E6%8C%81"><span class="nav-number">4.1.</span> <span class="nav-text">启用@AspectJ 支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Java-%E9%85%8D%E7%BD%AE%E5%90%AF%E7%94%A8-AspectJ-%E6%94%AF%E6%8C%81"><span class="nav-number">4.1.1.</span> <span class="nav-text">通过 Java 配置启用@AspectJ 支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-XML-%E9%85%8D%E7%BD%AE%E5%90%AF%E7%94%A8-AspectJ-%E6%94%AF%E6%8C%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">通过 XML 配置启用@AspectJ 支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2"><span class="nav-number">4.2.</span> <span class="nav-text">声明一个切面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">声明切入点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">4.3.1.</span> <span class="nav-text">支持的切入点指示符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">组合切入点表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%80%9A%E7%94%A8%E5%88%87%E5%85%A5%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.3.</span> <span class="nav-text">共享通用切入点定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Examples"><span class="nav-number">4.3.4.</span> <span class="nav-text">Examples</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-number">4.3.5.</span> <span class="nav-text">编写好的切入点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E9%80%9A%E7%9F%A5"><span class="nav-number">4.4.</span> <span class="nav-text">声明通知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Before-Advice"><span class="nav-number">4.4.1.</span> <span class="nav-text">Before Advice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#After-Returning-Advice"><span class="nav-number">4.4.2.</span> <span class="nav-text">After Returning Advice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#After-Throwing-Advice"><span class="nav-number">4.4.3.</span> <span class="nav-text">After Throwing Advice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#After-Finally-Advice"><span class="nav-number">4.4.4.</span> <span class="nav-text">After (Finally) Advice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Around-Advice"><span class="nav-number">4.4.5.</span> <span class="nav-text">Around Advice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Advice-Parameters"><span class="nav-number">4.4.6.</span> <span class="nav-text">Advice Parameters</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%BD%93%E5%89%8D%E7%9A%84-JoinPoint"><span class="nav-number">4.4.6.1.</span> <span class="nav-text">访问当前的 JoinPoint</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99Advice"><span class="nav-number">4.4.6.2.</span> <span class="nav-text">将参数传递给Advice</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E5%8F%82%E6%95%B0%E5%92%8C%E6%B3%9B%E5%9E%8B"><span class="nav-number">4.4.6.3.</span> <span class="nav-text">建议参数和泛型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0"><span class="nav-number">4.4.6.4.</span> <span class="nav-text">确定参数名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0"><span class="nav-number">4.4.6.5.</span> <span class="nav-text">处理参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Advice-Ordering"><span class="nav-number">4.4.7.</span> <span class="nav-text">Advice Ordering</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Introductions"><span class="nav-number">4.5.</span> <span class="nav-text">Introductions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E9%9D%A2%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.5.1.</span> <span class="nav-text">切面实例化模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP-%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.5.2.</span> <span class="nav-text">AOP 示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84-AOP-%E6%94%AF%E6%8C%81"><span class="nav-number">5.</span> <span class="nav-text">基于架构的 AOP 支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2-1"><span class="nav-number">5.1.</span> <span class="nav-text">声明一个切面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%88%87%E5%85%A5%E7%82%B9-1"><span class="nav-number">5.2.</span> <span class="nav-text">声明切入点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8EAdvice"><span class="nav-number">5.3.</span> <span class="nav-text">声明Advice</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Before-Advice-1"><span class="nav-number">5.3.1.</span> <span class="nav-text">Before Advice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%BB%BA%E8%AE%AE%E5%90%8E"><span class="nav-number">5.3.2.</span> <span class="nav-text">返回建议后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E5%87%BA%E5%BB%BA%E8%AE%AE%E5%90%8E"><span class="nav-number">5.3.3.</span> <span class="nav-text">提出建议后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%90%8E-%E5%BB%BA%E8%AE%AE%E5%90%8E"><span class="nav-number">5.3.4.</span> <span class="nav-text">(最后)建议后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Around-Advice-1"><span class="nav-number">5.3.5.</span> <span class="nav-text">Around Advice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Advice-Parameters-1"><span class="nav-number">5.3.6.</span> <span class="nav-text">Advice Parameters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Advice-Ordering-1"><span class="nav-number">5.3.7.</span> <span class="nav-text">Advice Ordering</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Introductions-1"><span class="nav-number">5.4.</span> <span class="nav-text">Introductions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-5-%E5%88%87%E9%9D%A2%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.5.5. 切面实例化模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-6-Advisors"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.5.6. Advisors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-7-AOP-%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.4.3.</span> <span class="nav-text">5.5.7. AOP 模式示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84-AOP-%E5%A3%B0%E6%98%8E%E6%A0%B7%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">选择要使用的 AOP 声明样式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-1-Spring-AOP-%E8%BF%98%E6%98%AF-Full-AspectJ%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">5.6.1. Spring AOP 还是 Full AspectJ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-2-AspectJ-%E6%88%96-Spring-AOP-%E7%9A%84-XML%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">5.6.2. @AspectJ 或 Spring AOP 的 XML？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-%E6%B7%B7%E5%90%88%E5%88%87%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">5.7. 混合切面类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">8.</span> <span class="nav-text">5.8. 代理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-1-%E4%BA%86%E8%A7%A3-AOP-%E4%BB%A3%E7%90%86"><span class="nav-number">8.1.</span> <span class="nav-text">5.8.1. 了解 AOP 代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-AspectJ-%E4%BB%A3%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">5.9. 以编程方式创建@AspectJ 代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-10-%E5%9C%A8-Spring-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8-AspectJ"><span class="nav-number">10.</span> <span class="nav-text">5.10. 在 Spring 应用程序中使用 AspectJ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-1-%E4%BD%BF%E7%94%A8-AspectJ-%E9%80%9A%E8%BF%87-Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%9F%9F%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.1.</span> <span class="nav-text">5.10.1. 使用 AspectJ 通过 Spring 依赖注入域对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Configurable-%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.1.1.</span> <span class="nav-text">单元测试@Configurable 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">10.1.2.</span> <span class="nav-text">处理多个应用程序上下文</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-2-AspectJ-%E7%9A%84%E5%85%B6%E4%BB%96-Spring-%E5%88%87%E9%9D%A2"><span class="nav-number">10.2.</span> <span class="nav-text">5.10.2. AspectJ 的其他 Spring 切面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-3-%E4%BD%BF%E7%94%A8-Spring-IoC-%E9%85%8D%E7%BD%AE-AspectJ-Aspects"><span class="nav-number">10.3.</span> <span class="nav-text">5.10.3. 使用 Spring IoC 配置 AspectJ Aspects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-4-%E5%9C%A8-Spring-Framework-%E4%B8%AD%E4%BD%BF%E7%94%A8-AspectJ-%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%BC%96%E7%BB%87"><span class="nav-number">10.4.</span> <span class="nav-text">5.10.4. 在 Spring Framework 中使用 AspectJ 进行加载时编织</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="nav-number">10.4.1.</span> <span class="nav-text">第一个例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Aspects"><span class="nav-number">10.4.2.</span> <span class="nav-text">Aspects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%98META-INF-aop-xml%E2%80%99"><span class="nav-number">10.4.3.</span> <span class="nav-text">‘META-INF&#x2F;aop.xml’</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E9%9C%80%E7%9A%84%E5%BA%93-JARS"><span class="nav-number">10.4.4.</span> <span class="nav-text">必需的库(JARS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Configuration"><span class="nav-number">10.4.5.</span> <span class="nav-text">Spring Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Environment-specific-Configuration"><span class="nav-number">10.4.6.</span> <span class="nav-text">Environment-specific Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tomcat"><span class="nav-number">10.4.7.</span> <span class="nav-text">Tomcat</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#WebLogic%EF%BC%8CWebSphere%EF%BC%8CResin%EF%BC%8CGlassFish-%E5%92%8C-JBoss"><span class="nav-number">10.4.7.0.1.</span> <span class="nav-text">WebLogic，WebSphere，Resin，GlassFish 和 JBoss</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8-Java-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">10.4.8.</span> <span class="nav-text">通用 Java 应用程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-11-%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90"><span class="nav-number">11.</span> <span class="nav-text">5.11. 更多资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Spring-AOP-API"><span class="nav-number">12.</span> <span class="nav-text">6. Spring AOP API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Spring-%E4%B8%AD%E7%9A%84-Pointcut-API"><span class="nav-number">12.1.</span> <span class="nav-text">6.1. Spring 中的 Pointcut API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-Concepts"><span class="nav-number">12.1.1.</span> <span class="nav-text">6.1.1. Concepts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E5%88%87%E5%85%A5%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">12.1.2.</span> <span class="nav-text">6.1.2. 切入点的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-AspectJ-%E8%A1%A8%E8%BE%BE%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-number">12.1.3.</span> <span class="nav-text">6.1.3. AspectJ 表达切入点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4-%E4%BE%BF%E6%8D%B7%E5%88%87%E5%85%A5%E7%82%B9%E5%AE%9E%E7%8E%B0"><span class="nav-number">12.1.4.</span> <span class="nav-text">6.1.4. 便捷切入点实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Static-Pointcuts"><span class="nav-number">12.1.4.1.</span> <span class="nav-text">Static Pointcuts</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-number">12.1.4.1.1.</span> <span class="nav-text">正则表达式切入点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Attribute-driven-Pointcuts"><span class="nav-number">12.1.4.1.2.</span> <span class="nav-text">Attribute-driven Pointcuts</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dynamic-pointcuts"><span class="nav-number">12.1.4.2.</span> <span class="nav-text">Dynamic pointcuts</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-number">12.1.4.2.1.</span> <span class="nav-text">控制流切入点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-5-%E5%88%87%E5%85%A5%E7%82%B9%E8%B6%85%E7%B1%BB"><span class="nav-number">12.1.5.</span> <span class="nav-text">6.1.5. 切入点超类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-number">12.1.6.</span> <span class="nav-text">6.1.6. 自定义切入点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Spring-%E5%92%A8%E8%AF%A2-API"><span class="nav-number">12.2.</span> <span class="nav-text">6.2. Spring 咨询 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E5%92%A8%E8%AF%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">12.2.1.</span> <span class="nav-text">6.2.1. 咨询生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-Spring-%E7%9A%84%E5%BB%BA%E8%AE%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.2.2.</span> <span class="nav-text">6.2.2. Spring 的建议类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%B4%E7%BB%95%E5%BB%BA%E8%AE%AE%E8%BF%9B%E8%A1%8C%E6%8B%A6%E6%88%AA"><span class="nav-number">12.2.2.1.</span> <span class="nav-text">围绕建议进行拦截</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Before-Advice-2"><span class="nav-number">12.2.2.2.</span> <span class="nav-text">Before Advice</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Throws-Advice"><span class="nav-number">12.2.2.3.</span> <span class="nav-text">Throws Advice</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%BB%BA%E8%AE%AE%E5%90%8E-1"><span class="nav-number">12.2.2.4.</span> <span class="nav-text">返回建议后</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Introduction-Advice"><span class="nav-number">12.2.2.5.</span> <span class="nav-text">Introduction Advice</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-Spring-%E7%9A%84-Advisor-API"><span class="nav-number">12.3.</span> <span class="nav-text">6.3. Spring 的 Advisor API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E4%BD%BF%E7%94%A8-ProxyFactoryBean-%E5%88%9B%E5%BB%BA-AOP-%E4%BB%A3%E7%90%86"><span class="nav-number">12.4.</span> <span class="nav-text">6.4. 使用 ProxyFactoryBean 创建 AOP 代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-Basics"><span class="nav-number">12.4.1.</span> <span class="nav-text">6.4.1. Basics</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-JavaBean-%E5%B1%9E%E6%80%A7"><span class="nav-number">12.4.2.</span> <span class="nav-text">6.4.2. JavaBean 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-%E5%9F%BA%E4%BA%8E-JDK-%E5%92%8C-CGLIB-%E7%9A%84%E4%BB%A3%E7%90%86"><span class="nav-number">12.4.3.</span> <span class="nav-text">6.4.3. 基于 JDK 和 CGLIB 的代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-4-%E4%BB%A3%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.4.4.</span> <span class="nav-text">6.4.4. 代理接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-5-%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="nav-number">12.4.5.</span> <span class="nav-text">6.4.5. 代理类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-6-%E4%BD%BF%E7%94%A8%E2%80%9C%E5%85%A8%E5%B1%80%E2%80%9D%E9%A1%BE%E9%97%AE"><span class="nav-number">12.4.6.</span> <span class="nav-text">6.4.6. 使用“全局”顾问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E7%AE%80%E6%B4%81%E7%9A%84%E4%BB%A3%E7%90%86%E5%AE%9A%E4%B9%89"><span class="nav-number">12.5.</span> <span class="nav-text">6.5. 简洁的代理定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E4%BD%BF%E7%94%A8-ProxyFactory-%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-AOP-%E4%BB%A3%E7%90%86"><span class="nav-number">12.6.</span> <span class="nav-text">6.6. 使用 ProxyFactory 以编程方式创建 AOP 代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E6%93%8D%E4%BD%9C%E5%BB%BA%E8%AE%AE%E5%AF%B9%E8%B1%A1"><span class="nav-number">12.7.</span> <span class="nav-text">6.7. 操作建议对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-%E4%BD%BF%E7%94%A8%E2%80%9C%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%E2%80%9D%E5%8A%9F%E8%83%BD"><span class="nav-number">12.8.</span> <span class="nav-text">6.8. 使用“自动代理”功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-8-1-%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86-Bean-%E5%AE%9A%E4%B9%89"><span class="nav-number">12.8.1.</span> <span class="nav-text">6.8.1. 自动代理 Bean 定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanNameAutoProxyCreator"><span class="nav-number">12.8.1.1.</span> <span class="nav-text">BeanNameAutoProxyCreator</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DefaultAdvisorAutoProxyCreator"><span class="nav-number">12.8.1.2.</span> <span class="nav-text">DefaultAdvisorAutoProxyCreator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-%E4%BD%BF%E7%94%A8-TargetSource-%E5%AE%9E%E7%8E%B0"><span class="nav-number">12.9.</span> <span class="nav-text">6.9. 使用 TargetSource 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-1-%E5%8F%AF%E7%83%AD%E4%BA%A4%E6%8D%A2%E7%9A%84%E7%9B%AE%E6%A0%87%E6%BA%90"><span class="nav-number">12.9.1.</span> <span class="nav-text">6.9.1. 可热交换的目标源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-2-%E6%B1%87%E9%9B%86%E7%9B%AE%E6%A0%87%E6%BA%90"><span class="nav-number">12.9.2.</span> <span class="nav-text">6.9.2. 汇集目标源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-3-%E5%8E%9F%E5%9E%8B%E7%9B%AE%E6%A0%87%E6%BA%90"><span class="nav-number">12.9.3.</span> <span class="nav-text">6.9.3. 原型目标源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-4-ThreadLocal-%E7%9B%AE%E6%A0%87%E6%BA%90"><span class="nav-number">12.9.4.</span> <span class="nav-text">6.9.4. ThreadLocal 目标源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-10-%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E5%BB%BA%E8%AE%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.10.</span> <span class="nav-text">6.10. 定义新的建议类型</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CHENPENGBLOG"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">CHENPENGBLOG</p>
  <div class="site-description" itemprop="description">全栈搞起来！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/yourname" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CHENPENGBLOG</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
