<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenpeng.pages.dev","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="接下来你将领略到一些 Git 可以实现的非常强大的功能，这些功能你可能并不会在日常操作中使用，但在某些时候你也许会需要。">
<meta property="og:type" content="article">
<meta property="og:title" content="git-git工具">
<meta property="og:url" content="https://chenpeng.pages.dev/2021/08/23/git/git-git%E5%B7%A5%E5%85%B7/index.html">
<meta property="og:site_name" content="陈鹏的博客">
<meta property="og:description" content="接下来你将领略到一些 Git 可以实现的非常强大的功能，这些功能你可能并不会在日常操作中使用，但在某些时候你也许会需要。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenpeng.pages.dev/2021/08/23/git/git-git%E5%B7%A5%E5%85%B7/18333fig0601-tn.png">
<meta property="article:published_time" content="2021-08-22T16:01:41.000Z">
<meta property="article:modified_time" content="2022-04-14T04:23:47.236Z">
<meta property="article:author" content="CHENPENGBLOG">
<meta property="article:tag" content="git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenpeng.pages.dev/2021/08/23/git/git-git%E5%B7%A5%E5%85%B7/18333fig0601-tn.png">

<link rel="canonical" href="https://chenpeng.pages.dev/2021/08/23/git/git-git%E5%B7%A5%E5%85%B7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>git-git工具 | 陈鹏的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">陈鹏的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">每天进步一点点😉</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenpeng.pages.dev/2021/08/23/git/git-git%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CHENPENGBLOG">
      <meta itemprop="description" content="记录！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈鹏的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          git-git工具
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-23 00:01:41" itemprop="dateCreated datePublished" datetime="2021-08-23T00:01:41+08:00">2021-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 12:23:47" itemprop="dateModified" datetime="2022-04-14T12:23:47+08:00">2022-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>接下来你将领略到一些 Git 可以实现的非常强大的功能，这些功能你可能并不会在日常操作中使用，但在某些时候你也许会需要。</p>
<span id="more"></span>

<h2 id="修订版本（Revision）选择"><a href="#修订版本（Revision）选择" class="headerlink" title="修订版本（Revision）选择"></a>修订版本（Revision）选择</h2><p>Git 允许你通过几种方法来指明特定的或者一定范围内的提交。了解它们并不是必需的，但是了解一下总没坏处。</p>
<h3 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h3><p>显然你可以使用给出的 SHA-1 值来指明一次提交，不过也有更加人性化的方法来做同样的事。本节概述了指明单个提交的诸多方法。</p>
<h3 id="简短的SHA"><a href="#简短的SHA" class="headerlink" title="简短的SHA"></a>简短的SHA</h3><p>Git 很聪明，它能够通过你提供的前几个字符来识别你想要的那次提交，只要你提供的那部分 SHA-1 不短于四个字符，并且没有歧义——也就是说，当前仓库中只有一个对象以这段 SHA-1 开头。</p>
<p>例如，想要查看一次指定的提交，假设你运行 <code>git log</code> 命令并找到你增加了功能的那次提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 734713bc047d87bf7eac9674765ae793478c50d3</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 2 18:32:33 2009 -0800</span><br><span class="line"></span><br><span class="line">    fixed refs handling, added gc auto, updated tests</span><br><span class="line"></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Merge: 1c002dd... 35cfb2b...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &#x27;phedders/rdocs&#x27;</span><br><span class="line"></span><br><span class="line">commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 14:58:32 2008 -0800</span><br><span class="line"></span><br><span class="line">    added some blame and merge stuff</span><br></pre></td></tr></table></figure>

<p>假设是 <code>1c002dd....</code> 。如果你想 <code>git show</code> 这次提交，下面的命令是等价的（假设简短的版本没有歧义）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">$ git show 1c002dd4b536e7479f</span><br><span class="line">$ git show 1c002d</span><br></pre></td></tr></table></figure>

<p>Git 可以为你的 SHA-1 值生成出简短且唯一的缩写。如果你传递 <code>--abbrev-commit</code> 给 <code>git log</code> 命令，输出结果里就会使用简短且唯一的值；它默认使用七个字符来表示，不过必要时为了避免 SHA-1 的歧义，会增加字符数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --abbrev-commit --pretty=oneline</span><br><span class="line">ca82a6d changed the version number</span><br><span class="line">085bb3b removed unnecessary test code</span><br><span class="line">a11bef0 first commit</span><br></pre></td></tr></table></figure>

<p>通常在一个项目中，使用八到十个字符来避免 SHA-1 歧义已经足够了。最大的 Git 项目之一，Linux 内核，目前也只需要最长 40 个字符中的 12 个字符来保持唯一性。</p>
<h3 id="关于-SHA-1-的简短说明"><a href="#关于-SHA-1-的简短说明" class="headerlink" title="关于 SHA-1 的简短说明"></a>关于 SHA-1 的简短说明</h3><p>许多人可能会担心一个问题：在随机的偶然情况下，在他们的仓库里会出现两个具有相同 SHA-1 值的对象。那会怎么样呢？</p>
<p>如果你真的向仓库里提交了一个跟之前的某个对象具有相同 SHA-1 值的对象，Git 将会发现之前的那个对象已经存在在 Git 数据库中，并认为它已经被写入了。如果什么时候你想再次检出那个对象时，你会总是得到先前的那个对象的数据。</p>
<p>不过，你应该了解到，这种情况发生的概率是多么微小。SHA-1 摘要长度是 20 字节，也就是 160 位。为了保证有 50% 的概率出现一次冲突，需要 2^80 个随机哈希的对象（计算冲突机率的公式是 <code>p = (n(n-1)/2) * (1/2^160)</code>)。2^80 是 1.2 x 10^24，也就是一亿亿亿，那是地球上沙粒总数的 1200 倍。</p>
<p>现在举例说一下怎样才能产生一次 SHA-1 冲突。如果地球上 65 亿的人类都在编程，每人每秒都在产生等价于整个 Linux 内核历史（一百万个 Git 对象）的代码，并将之提交到一个巨大的 Git 仓库里面，那将花费 5 年的时间才会产生足够的对象，使其拥有 50% 的概率产生一次 SHA-1 对象冲突。这要比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。</p>
<h3 id="分支引用"><a href="#分支引用" class="headerlink" title="分支引用"></a>分支引用</h3><p>指明一次提交的最直接的方法要求有一个指向它的分支引用。这样，你就可以在任何需要一个提交对象或者 SHA-1 值的 Git 命令中使用该分支名称了。如果你想要显示一个分支的最后一次提交的对象，例如假设 <code>topic1</code> 分支指向 <code>ca82a6d</code>，那么下面的命令是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git show ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">$ git show topic1</span><br></pre></td></tr></table></figure>

<p>如果你想知道某个分支指向哪个特定的 SHA，或者想看任何一个例子中被简写的 SHA-1，你可以使用一个叫做 <code>rev-parse</code> 的 Git 探测工具。在第 9 章你可以看到关于探测工具的更多信息；简单来说，<code>rev-parse</code> 是为了底层操作而不是日常操作设计的。不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。这里你可以对你的分支运执行 <code>rev-parse</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rev-parse topic1</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure>

<h3 id="引用日志里的简称"><a href="#引用日志里的简称" class="headerlink" title="引用日志里的简称"></a>引用日志里的简称</h3><p>在你工作的同时，Git 在后台的工作之一就是保存一份引用日志——一份记录最近几个月你的 HEAD 和分支引用的日志。</p>
<p>你可以使用 <code>git reflog</code> 来查看引用日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">734713b HEAD@&#123;0&#125;: commit: fixed refs handling, added gc auto, updated</span><br><span class="line">d921970 HEAD@&#123;1&#125;: merge phedders/rdocs: Merge made by recursive.</span><br><span class="line">1c002dd HEAD@&#123;2&#125;: commit: added some blame and merge stuff</span><br><span class="line">1c36188 HEAD@&#123;3&#125;: rebase -i (squash): updating HEAD</span><br><span class="line">95df984 HEAD@&#123;4&#125;: commit: # This is a combination of two commits.</span><br><span class="line">1c36188 HEAD@&#123;5&#125;: rebase -i (squash): updating HEAD</span><br><span class="line">7e05da5 HEAD@&#123;6&#125;: rebase -i (pick): updating HEAD</span><br></pre></td></tr></table></figure>

<p>每次你的分支顶端因为某些原因被修改时，Git 就会为你将信息保存在这个临时历史记录里面。你也可以使用这份数据来指明更早的分支。如果你想查看仓库中 HEAD 在五次前的值，你可以使用引用日志的输出中的 <code>@&#123;n&#125;</code> 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD@&#123;5&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以使用这个语法来查看某个分支在一定时间前的位置。例如，想看你的 <code>master</code> 分支昨天在哪，你可以输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show master@&#123;yesterday&#125;</span><br></pre></td></tr></table></figure>

<p>它就会显示昨天分支的顶端在哪。这项技术只对还在你引用日志里的数据有用，所以不能用来查看比几个月前还早的提交。</p>
<p>想要看类似于 <code>git log</code> 输出格式的引用日志信息，你可以运行 <code>git log -g</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log -g master</span><br><span class="line">commit 734713bc047d87bf7eac9674765ae793478c50d3</span><br><span class="line">Reflog: master@&#123;0&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: commit: fixed refs handling, added gc auto, updated</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 2 18:32:33 2009 -0800</span><br><span class="line"></span><br><span class="line">    fixed refs handling, added gc auto, updated tests</span><br><span class="line"></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Reflog: master@&#123;1&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: merge phedders/rdocs: Merge made by recursive.</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &#x27;phedders/rdocs&#x27;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，引用日志信息只存在于本地——这是一个记录你在你自己的仓库里做过什么的日志。其他人拷贝的仓库里的引用日志不会和你的相同；而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。<code>git show HEAD@&#123;2.months.ago&#125;</code> 这条命令只有在你克隆了一个项目至少两个月时才会有用——如果你是五分钟前克隆的仓库，那么它将不会有结果返回。</p>
<h3 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h3><p>另一种指明某次提交的常用方法是通过它的祖先。如果你在引用最后加上一个 <code>^</code>，Git 将其理解为此次提交的父提交。 假设你的工程历史是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&#x27;%h %s&#x27; --graph</span><br><span class="line">* 734713b fixed refs handling, added gc auto, updated tests</span><br><span class="line">*   d921970 Merge commit &#x27;phedders/rdocs&#x27;</span><br><span class="line">|\</span><br><span class="line">| * 35cfb2b Some rdoc changes</span><br><span class="line">* | 1c002dd added some blame and merge stuff</span><br><span class="line">|/</span><br><span class="line">* 1c36188 ignore *.gem</span><br><span class="line">* 9b29157 add open3_detach to gemspec file list</span><br></pre></td></tr></table></figure>

<p>那么，想看上一次提交，你可以使用 <code>HEAD^</code>，意思是“HEAD 的父提交”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD^</span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Merge: 1c002dd... 35cfb2b...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &#x27;phedders/rdocs&#x27;</span><br></pre></td></tr></table></figure>

<p>你也可以在 <code>^</code> 后添加一个数字——例如，<code>d921970^2</code> 意思是“d921970 的第二父提交”。这种语法只在合并提交时有用，因为合并提交可能有多个父提交。第一父提交是你合并时所在分支，而第二父提交是你所合并的分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git show d921970^</span><br><span class="line">commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 14:58:32 2008 -0800</span><br><span class="line"></span><br><span class="line">    added some blame and merge stuff</span><br><span class="line"></span><br><span class="line">$ git show d921970^2</span><br><span class="line">commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548</span><br><span class="line">Author: Paul Hedderly &lt;paul+git@mjr.org&gt;</span><br><span class="line">Date:   Wed Dec 10 22:22:03 2008 +0000</span><br><span class="line"></span><br><span class="line">    Some rdoc changes</span><br></pre></td></tr></table></figure>

<p>另外一个指明祖先提交的方法是 <code>~</code>。这也是指向第一父提交，所以 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。当你指定数字的时候就明显不一样了。<code>HEAD~2</code> 是指“第一父提交的第一父提交”，也就是“祖父提交”——它会根据你指定的次数检索第一父提交。例如，在上面列出的历史记录里面，<code>HEAD~3</code> 会是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD~3</span><br><span class="line">commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d</span><br><span class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</span><br><span class="line">Date:   Fri Nov 7 13:47:59 2008 -0500</span><br><span class="line"></span><br><span class="line">    ignore *.gem</span><br></pre></td></tr></table></figure>

<p>也可以写成 <code>HEAD^^^</code>，同样是第一父提交的第一父提交的第一父提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD^^^</span><br><span class="line">commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d</span><br><span class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</span><br><span class="line">Date:   Fri Nov 7 13:47:59 2008 -0500</span><br><span class="line"></span><br><span class="line">    ignore *.gem</span><br></pre></td></tr></table></figure>

<p>你也可以混合使用这些语法——你可以通过 <code>HEAD~3^2</code> 指明先前引用的第二父提交（假设它是一个合并提交）。</p>
<h3 id="提交范围"><a href="#提交范围" class="headerlink" title="提交范围"></a>提交范围</h3><p>现在你已经可以指明单次的提交，让我们来看看怎样指明一定范围的提交。这在你管理分支的时候尤显重要——如果你有很多分支，你可以指明范围来圈定一些问题的答案，比如：“这个分支上我有哪些工作还没合并到主分支的？”</p>
<h4 id="双点"><a href="#双点" class="headerlink" title="双点"></a>双点</h4><p>最常用的指明范围的方法是双点的语法。这种语法主要是让 Git 区分出可从一个分支中获得而不能从另一个分支中获得的提交。例如，假设你有类似于图 6-1 的提交历史。</p>
<p><img src="/2021/08/23/git/git-git%E5%B7%A5%E5%85%B7/18333fig0601-tn.png" alt="img"><br>图 6-1. 范围选择的提交历史实例</p>
<p>你想要查看你的试验分支上哪些没有被提交到主分支，那么你就可以使用 <code>master..experiment</code> 来让 Git 显示这些提交的日志——这句话的意思是“所有可从experiment分支中获得而不能从master分支中获得的提交”。为了使例子简单明了，我使用了图标中提交对象的字母来代替真实日志的输出，所以会显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log master..experiment</span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<p>另一方面，如果你想看相反的——所有在 <code>master</code> 而不在 <code>experiment</code> 中的分支——你可以交换分支的名字。<code>experiment..master</code> 显示所有可在 <code>master</code> 获得而在 <code>experiment</code> 中不能的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log experiment..master</span><br><span class="line">F</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<p>这在你想保持 <code>experiment</code> 分支最新和预览你将合并的提交的时候特别有用。这个语法的另一种常见用途是查看你将把什么推送到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log origin/master..HEAD</span><br></pre></td></tr></table></figure>

<p>这条命令显示任何在你当前分支上而不在远程<code>origin</code> 上的提交。如果你运行 <code>git push</code> 并且的你的当前分支正在跟踪 <code>origin/master</code>，被<code>git log origin/master..HEAD</code> 列出的提交就是将被传输到服务器上的提交。 你也可以留空语法中的一边来让 Git 来假定它是 HEAD。例如，输入 <code>git log origin/master..</code> 将得到和上面的例子一样的结果—— Git 使用 HEAD 来代替不存在的一边。</p>
<h4 id="多点"><a href="#多点" class="headerlink" title="多点"></a>多点</h4><p>双点语法就像速记一样有用；但是你也许会想针对两个以上的分支来指明修订版本，比如查看哪些提交被包含在某些分支中的一个，但是不在你当前的分支上。Git允许你在引用前使用<code>^</code>字符或者<code>--not</code>指明你不希望提交被包含其中的分支。因此下面三个命令是等同的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log refA..refB</span><br><span class="line">$ git log ^refA refB</span><br><span class="line">$ git log refB --not refA</span><br></pre></td></tr></table></figure>

<p>这样很好，因为它允许你在查询中指定多于两个的引用，而这是双点语法所做不到的。例如，如果你想查找所有从<code>refA</code>或<code>refB</code>包含的但是不被<code>refC</code>包含的提交，你可以输入下面中的一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log refA refB ^refC</span><br><span class="line">$ git log refA refB --not refC</span><br></pre></td></tr></table></figure>

<p>这建立了一个非常强大的修订版本查询系统，应该可以帮助你解决分支里包含了什么这个问题。</p>
<h4 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h4><p>最后一种主要的范围选择语法是三点语法，这个可以指定被两个引用中的一个包含但又不被两者同时包含的分支。回过头来看一下图6-1里所列的提交历史的例子。 如果你想查看<code>master</code>或者<code>experiment</code>中包含的但不是两者共有的引用，你可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log master...experiment</span><br><span class="line">F</span><br><span class="line">E</span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<p>这个再次给出你普通的<code>log</code>输出但是只显示那四次提交的信息，按照传统的提交日期排列。</p>
<p>这种情形下，<code>log</code>命令的一个常用参数是<code>--left-right</code>，它会显示每个提交到底处于哪一侧的分支。这使得数据更加有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --left-right master...experiment</span><br><span class="line">&lt; F</span><br><span class="line">&lt; E</span><br><span class="line">&gt; D</span><br><span class="line">&gt; C</span><br></pre></td></tr></table></figure>

<p>有了以上工具，让Git知道你要察看哪些提交就容易得多了。</p>
<h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>Git提供了很多脚本来辅助某些命令行任务。这里，你将看到一些交互式命令，它们帮助你方便地构建只包含特定组合和部分文件的提交。在你修改了一大批文件然后决定将这些变更分布在几个各有侧重的提交而不是单个又大又乱的提交时，这些工具非常有用。用这种方法，你可以确保你的提交在逻辑上划分为相应的变更集，以便于供和你一起工作的开发者审阅。如果你运行<code>git add</code>时加上<code>-i</code>或者<code>--interactive</code>选项，Git就进入了一个交互式的shell模式，显示一些类似于下面的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add -i</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure>

<p>你会看到这个命令以一个完全不同的视图显示了你的暂存区——主要是你通过<code>git status</code>得到的那些信息但是稍微简洁但信息更加丰富一些。它在左侧列出了你暂存的变更，在右侧列出了未被暂存的变更。</p>
<p>在这之后是一个命令区。这里你可以做很多事情，包括暂存文件，撤回文件，暂存部分文件，加入未被追踪的文件，查看暂存文件的差别。</p>
<h3 id="暂存和撤回文件"><a href="#暂存和撤回文件" class="headerlink" title="暂存和撤回文件"></a>暂存和撤回文件</h3><p>如果你在<code>What now&gt;</code>的提示后输入<code>2</code>或者<code>u</code>，这个脚本会提示你那些文件你想要暂存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 2</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Update&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>如果想暂存TODO和index.html，你可以输入相应的编号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Update&gt;&gt; 1,2</span><br><span class="line">           staged     unstaged path</span><br><span class="line">* 1:    unchanged        +0/-1 TODO</span><br><span class="line">* 2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Update&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>每个文件旁边的<code>*</code>表示选中的文件将被暂存。如果你在<code>update&gt;&gt;</code>提示后直接敲入回车，Git会替你把所有选中的内容暂存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Update&gt;&gt;</span><br><span class="line">updated 2 paths</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>现在你可以看到TODO和index.html文件被暂存了同时simplegit.rb文件仍然未被暂存。如果这时你想要撤回TODO文件，就使用<code>3</code>或者<code>r</code>（代表revert，恢复）选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 3</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Revert&gt;&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">* 1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Revert&gt;&gt; [enter]</span><br><span class="line">reverted one path</span><br></pre></td></tr></table></figure>

<p>再次查看Git的状态，你会看到你已经撤回了TODO文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>要查看你暂存内容的差异，你可以使用<code>6</code>或者<code>d</code>（表示diff）命令。它会显示你暂存文件的列表，你可以选择其中的几个，显示其被暂存的差异。这跟你在命令行下指定<code>git diff --cached</code>非常相似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 6</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +1/-1      nothing index.html</span><br><span class="line">Review diff&gt;&gt; 1</span><br><span class="line">diff --git a/index.html b/index.html</span><br><span class="line">index 4d07108..4335f49 100644</span><br><span class="line">--- a/index.html</span><br><span class="line">+++ b/index.html</span><br><span class="line">@@ -16,7 +16,7 @@ Date Finder</span><br><span class="line"></span><br><span class="line"> &lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;</span><br><span class="line">+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>通过这些基本命令，你可以使用交互式增加模式更加方便地处理暂存区。</p>
<h3 id="暂存补丁"><a href="#暂存补丁" class="headerlink" title="暂存补丁"></a>暂存补丁</h3><p>只让Git暂存文件的某些部分而忽略其他也是有可能的。例如，你对simplegit.rb文件作了两处修改但是只想暂存其中一个而忽略另一个，在Git中实现这一点非常容易。在交互式的提示符下，输入<code>5</code>或者<code>p</code>（表示patch，补丁）。Git会询问哪些文件你希望部分暂存；然后对于被选中文件的每一节，他会逐个显示文件的差异区块并询问你是否希望暂存他们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index dd5ecc4..57399e0 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -22,7 +22,7 @@ class SimpleGit</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def log(treeish = &#x27;master&#x27;)</span><br><span class="line">-    command(&quot;git log -n 25 #&#123;treeish&#125;&quot;)</span><br><span class="line">+    command(&quot;git log -n 30 #&#123;treeish&#125;&quot;)</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def blame(path)</span><br><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</span><br></pre></td></tr></table></figure>

<p>此处你有很多选择。输入<code>?</code>可以显示列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?</span><br><span class="line">y - stage this hunk</span><br><span class="line">n - do not stage this hunk</span><br><span class="line">a - stage this and all the remaining hunks in the file</span><br><span class="line">d - do not stage this hunk nor any of the remaining hunks in the file</span><br><span class="line">g - select a hunk to go to</span><br><span class="line">/ - search for a hunk matching the given regex</span><br><span class="line">j - leave this hunk undecided, see next undecided hunk</span><br><span class="line">J - leave this hunk undecided, see next hunk</span><br><span class="line">k - leave this hunk undecided, see previous undecided hunk</span><br><span class="line">K - leave this hunk undecided, see previous hunk</span><br><span class="line">s - split the current hunk into smaller hunks</span><br><span class="line">e - manually edit the current hunk</span><br><span class="line">? - print help</span><br></pre></td></tr></table></figure>

<p>如果你想暂存各个区块，通常你会输入<code>y</code>或者<code>n</code>，但是暂存特定文件里的全部区块或者暂时跳过对一个区块的处理同样也很有用。如果你暂存了文件的一个部分而保留另外一个部分不被暂存，你的状态输出看起来会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:        +1/-1        +4/-0 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>simplegit.rb的状态非常有意思。它显示有几行被暂存了，有几行没有。你部分地暂存了这个文件。在这时，你可以退出交互式脚本然后运行<code>git commit</code>来提交部分暂存的文件。</p>
<p>最后你也可以不通过交互式增加的模式来实现部分文件暂存——你可以在命令行下通过<code>git add -p</code>或者<code>git add --patch</code>来启动同样的脚本。</p>
<h2 id="储藏（Stashing）"><a href="#储藏（Stashing）" class="headerlink" title="储藏（Stashing）"></a>储藏（Stashing）</h2><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是<code>git stash</code>命令。</p>
<p>“‘储藏”“可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p>
<h3 id="储藏你的工作"><a href="#储藏你的工作" class="headerlink" title="储藏你的工作"></a>储藏你的工作</h3><p>为了演示这一功能，你可以进入你的项目，在一些文件上进行工作，有可能还暂存其中一个变更。如果你运行 <code>git status</code>，你可以看到你的中间状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 <code>git stash</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state \</span><br><span class="line">  &quot;WIP on master: 049d078 added the index file&quot;</span><br><span class="line">HEAD is now at 049d078 added the index file</span><br><span class="line">(To restore them type &quot;git stash apply&quot;)</span><br></pre></td></tr></table></figure>

<p>你的工作目录就干净了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<p>这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 <code>git stash list</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br></pre></td></tr></table></figure>

<p>在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。你可以重新应用你刚刚实施的储藏，所采用的命令就是之前在原始的 stash 命令的帮助输出里提示的：<code>git stash apply</code>。如果你想应用更早的储藏，你可以通过名字指定它，像这样：<code>git stash apply stash@&#123;2&#125;</code>。如果你不指明，Git 默认使用最近的储藏并尝试应用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>你可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p>
<p>对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。想那样的话，你必须在运行 <code>git stash apply</code> 命令时带上一个 <code>--index</code> 的选项来告诉命令重新应用被暂存的变更。如果你是这么做的，你应该已经回到你原来的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply --index</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行 <code>git stash drop</code>，加上你希望移除的储藏的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure>

<p>你也可以运行 <code>git stash pop</code> 来重新应用储藏，同时立刻将其从堆栈中移走。</p>
<h3 id="取消储藏-Un-applying-a-Stash"><a href="#取消储藏-Un-applying-a-Stash" class="headerlink" title="取消储藏(Un-applying a Stash)"></a>取消储藏(Un-applying a Stash)</h3><p>在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git没有提供类似于 <code>stash unapply</code> 的命令，但是可以通过取消该储藏的补丁达到同样的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure>

<p>同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show -p | git apply -R</span><br></pre></td></tr></table></figure>

<p>你可能会想要新建一个別名，在你的 Git 里增加一个 <code>stash-unapply</code> 命令，这样更有效率。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.stash-unapply &#x27;!git stash show -p | git apply -R&#x27;</span><br><span class="line">$ git stash apply</span><br><span class="line">$ #... work work work</span><br><span class="line">$ git stash-unapply</span><br></pre></td></tr></table></figure>

<h3 id="从储藏中创建分支"><a href="#从储藏中创建分支" class="headerlink" title="从储藏中创建分支"></a>从储藏中创建分支</h3><p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 <code>git stash branch</code>，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash branch testchanges</span><br><span class="line">Switched to a new branch &quot;testchanges&quot;</span><br><span class="line"># On branch testchanges</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure>

<p>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p>
<h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><p>很多时候，在 Git 上工作的时候，你也许会由于某种原因想要修订你的提交历史。Git 的一个卓越之处就是它允许你在最后可能的时刻再作决定。你可以在你即将提交暂存区时决定什么文件归入哪一次提交，你可以使用 stash 命令来决定你暂时搁置的工作，你可以重写已经发生的提交以使它们看起来是另外一种样子。这个包括改变提交的次序、改变说明或者修改提交中包含的文件，将提交归并、拆分或者完全删除——这一切在你尚未开始将你的工作和别人共享前都是可以的。</p>
<p>在这一节中，你会学到如何完成这些很有用的任务以使你的提交历史在你将其共享给别人之前变成你想要的样子。</p>
<h3 id="改变最近一次提交"><a href="#改变最近一次提交" class="headerlink" title="改变最近一次提交"></a>改变最近一次提交</h3><p>改变最近一次提交也许是最常见的重写历史的行为。对于你的最近一次提交，你经常想做两件基本事情：改变提交说明，或者改变你刚刚通过增加，改变，删除而记录的快照。</p>
<p>如果你只想修改最近一次提交说明，这非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>这会把你带入文本编辑器，里面包含了你最近一次提交说明，供你修改。当你保存并退出编辑器，这个编辑器会写入一个新的提交，里面包含了那个说明，并且让它成为你的新的最近一次提交。</p>
<p>如果你完成提交后又想修改被提交的快照，增加或者修改其中的文件，可能因为你最初提交时，忘了添加一个新建的文件，这个过程基本上一样。你通过修改文件然后对其运行<code>git add</code>或对一个已被记录的文件运行<code>git rm</code>，随后的<code>git commit --amend</code>会获取你当前的暂存区并将它作为新提交对应的快照。</p>
<p>使用这项技术的时候你必须小心，因为修正会改变提交的SHA-1值。这个很像是一次非常小的rebase——不要在你最近一次提交被推送后还去修正它。</p>
<h3 id="修改多个提交说明"><a href="#修改多个提交说明" class="headerlink" title="修改多个提交说明"></a>修改多个提交说明</h3><p>要修改历史中更早的提交，你必须采用更复杂的工具。Git没有一个修改历史的工具，但是你可以使用rebase工具来衍合一系列的提交到它们原来所在的HEAD上而不是移到新的上。依靠这个交互式的rebase工具，你就可以停留在每一次提交后，如果你想修改或改变说明、增加文件或任何其他事情。你可以通过给<code>git rebase</code>增加<code>-i</code>选项来以交互方式地运行rebase。你必须通过告诉命令衍合到哪次提交，来指明你需要重写的提交的回溯深度。</p>
<p>例如，你想修改最近三次的提交说明，或者其中任意一次，你必须给<code>git rebase -i</code>提供一个参数，指明你想要修改的提交的父提交，例如<code>HEAD~2</code>或者<code>HEAD~3</code>。可能记住<code>~3</code>更加容易，因为你想修改最近三次提交；但是请记住你事实上所指的是四次提交之前，即你想修改的提交的父提交。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>再次提醒这是一个衍合命令——<code>HEAD~3..HEAD</code>范围内的每一次提交都会被重写，无论你是否修改说明。不要涵盖你已经推送到中心服务器的提交——这么做会使其他开发者产生混乱，因为你提供了同样变更的不同版本。</p>
<p>运行这个命令会为你的文本编辑器提供一个提交列表，看起来像下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br><span class="line"></span><br><span class="line"># Rebase 710f0f8..a5f4a0d onto 710f0f8</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>很重要的一点是你得注意这些提交的顺序与你通常通过<code>log</code>命令看到的是相反的。如果你运行<code>log</code>，你会看到下面这样的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h %s&quot; HEAD~3..HEAD</span><br><span class="line">a5f4a0d added cat-file</span><br><span class="line">310154e updated README formatting and added blame</span><br><span class="line">f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure>

<p>请注意这里的倒序。交互式的rebase给了你一个即将运行的脚本。它会从你在命令行上指明的提交开始(<code>HEAD~3</code>)然后自上至下重播每次提交里引入的变更。它将最早的列在顶上而不是最近的，因为这是第一个需要重播的。</p>
<p>你需要修改这个脚本来让它停留在你想修改的变更上。要做到这一点，你只要将你想修改的每一次提交前面的pick改为edit。例如，只想修改第三次提交说明的话，你就像下面这样修改文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>当你保存并退出编辑器，Git会倒回至列表中的最后一次提交，然后把你送到命令行中，同时显示以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br><span class="line">Stopped at 7482e0d... updated the gemspec to hopefully work better</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">       git commit --amend</span><br><span class="line"></span><br><span class="line">Once you’re satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">       git rebase --continue</span><br></pre></td></tr></table></figure>

<p>这些指示很明确地告诉了你该干什么。输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>修改提交说明，退出编辑器。然后，运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure>

<p>这个命令会自动应用其他两次提交，你就完成任务了。如果你将更多行的 pick 改为 edit ，你就能对你想修改的提交重复这些步骤。Git每次都会停下，让你修正提交，完成后继续运行。</p>
<h3 id="重排提交"><a href="#重排提交" class="headerlink" title="重排提交"></a>重排提交</h3><p>你也可以使用交互式的衍合来彻底重排或删除提交。如果你想删除”added cat-file”这个提交并且修改其他两次提交引入的顺序，你将rebase脚本从这个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>改为这个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure>

<p>当你保存并退出编辑器，Git 将分支倒回至这些提交的父提交，应用<code>310154e</code>，然后<code>f7f3f6d</code>，接着停止。你有效地修改了这些提交的顺序并且彻底删除了”added cat-file”这次提交。</p>
<h3 id="压制-Squashing-提交"><a href="#压制-Squashing-提交" class="headerlink" title="压制(Squashing)提交"></a>压制(Squashing)提交</h3><p>交互式的衍合工具还可以将一系列提交压制为单一提交。脚本在 rebase 的信息里放了一些有用的指示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>如果不用”pick”或者”edit”，而是指定”squash”，Git 会同时应用那个变更和它之前的变更并将提交说明归并。因此，如果你想将这三个提交合并为单一提交，你可以将脚本修改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">squash 310154e updated README formatting and added blame</span><br><span class="line">squash a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>当你保存并退出编辑器，Git 会应用全部三次变更然后将你送回编辑器来归并三次提交说明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># The first commit&#x27;s message is:</span><br><span class="line">changed my name a bit</span><br><span class="line"></span><br><span class="line"># This is the 2nd commit message:</span><br><span class="line"></span><br><span class="line">updated README formatting and added blame</span><br><span class="line"></span><br><span class="line"># This is the 3rd commit message:</span><br><span class="line"></span><br><span class="line">added cat-file</span><br></pre></td></tr></table></figure>

<p>当你保存之后，你就拥有了一个包含前三次提交的全部变更的单一提交。</p>
<h3 id="拆分提交"><a href="#拆分提交" class="headerlink" title="拆分提交"></a>拆分提交</h3><p>拆分提交就是撤销一次提交，然后多次部分地暂存或提交直到结束。例如，假设你想将三次提交中的中间一次拆分。将”updated README formatting and added blame”拆分成两次提交：第一次为”updated README formatting”，第二次为”added blame”。你可以在<code>rebase -i</code>脚本中修改你想拆分的提交前的指令为”edit”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">edit 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>然后，这个脚本就将你带入命令行，你重置那次提交，提取被重置的变更，从中创建多次提交。当你保存并退出编辑器，Git 倒回到列表中第一次提交的父提交，应用第一次提交（<code>f7f3f6d</code>），应用第二次提交（<code>310154e</code>），然后将你带到控制台。那里你可以用<code>git reset HEAD^</code>对那次提交进行一次混合的重置，这将撤销那次提交并且将修改的文件撤回。此时你可以暂存并提交文件，直到你拥有多次提交，结束后，运行<code>git rebase --continue</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;updated README formatting&#x27;</span><br><span class="line">$ git add lib/simplegit.rb</span><br><span class="line">$ git commit -m &#x27;added blame&#x27;</span><br><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure>

<p>Git在脚本中应用了最后一次提交（<code>a5f4a0d</code>），你的历史看起来就像这样了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log -4 --pretty=format:&quot;%h %s&quot;</span><br><span class="line">1c002dd added cat-file</span><br><span class="line">9b29157 added blame</span><br><span class="line">35cfb2b updated README formatting</span><br><span class="line">f3cc40e changed my name a bit</span><br></pre></td></tr></table></figure>

<p>再次提醒，这会修改你列表中的提交的 SHA 值，所以请确保这个列表里不包含你已经推送到共享仓库的提交。</p>
<h3 id="核弹级选项-filter-branch"><a href="#核弹级选项-filter-branch" class="headerlink" title="核弹级选项: filter-branch"></a>核弹级选项: filter-branch</h3><p>如果你想用脚本的方式修改大量的提交，还有一个重写历史的选项可以用——例如，全局性地修改电子邮件地址或者将一个文件从所有提交中删除。这个命令是<code>filter-branch</code>，这个会大面积地修改你的历史，所以你很有可能不该去用它，除非你的项目尚未公开，没有其他人在你准备修改的提交的基础上工作。尽管如此，这个可以非常有用。你会学习一些常见用法，借此对它的能力有所认识。</p>
<h4 id="从所有提交中删除一个文件"><a href="#从所有提交中删除一个文件" class="headerlink" title="从所有提交中删除一个文件"></a>从所有提交中删除一个文件</h4><p>这个经常发生。有些人不经思考使用<code>git add .</code>，意外地提交了一个巨大的二进制文件，你想将它从所有地方删除。也许你不小心提交了一个包含密码的文件，而你想让你的项目开源。<code>filter-branch</code>大概会是你用来清理整个历史的工具。要从整个历史中删除一个名叫password.txt的文件，你可以在<code>filter-branch</code>上使用<code>--tree-filter</code>选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --tree-filter &#x27;rm -f passwords.txt&#x27; HEAD</span><br><span class="line">Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)</span><br><span class="line">Ref &#x27;refs/heads/master&#x27; was rewritten</span><br></pre></td></tr></table></figure>

<p><code>--tree-filter</code>选项会在每次检出项目时先执行指定的命令然后重新提交结果。在这个例子中，你会在所有快照中删除一个名叫 password.txt 的文件，无论它是否存在。如果你想删除所有不小心提交上去的编辑器备份文件，你可以运行类似<code>git filter-branch --tree-filter &quot;find * -type f -name &#39;*~&#39; -delete&quot; HEAD</code>的命令。</p>
<p>你可以观察到 Git 重写目录树并且提交，然后将分支指针移到末尾。一个比较好的办法是在一个测试分支上做这些然后在你确定产物真的是你所要的之后，再 hard-reset 你的主分支。要在你所有的分支上运行<code>filter-branch</code>的话，你可以传递一个<code>--all</code>给命令。</p>
<h4 id="将一个子目录设置为新的根目录"><a href="#将一个子目录设置为新的根目录" class="headerlink" title="将一个子目录设置为新的根目录"></a>将一个子目录设置为新的根目录</h4><p>假设你完成了从另外一个代码控制系统的导入工作，得到了一些没有意义的子目录（trunk, tags等等）。如果你想让<code>trunk</code>子目录成为每一次提交的新的项目根目录，<code>filter-branch</code>也可以帮你做到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --subdirectory-filter trunk HEAD</span><br><span class="line">Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)</span><br><span class="line">Ref &#x27;refs/heads/master&#x27; was rewritten</span><br></pre></td></tr></table></figure>

<p>现在你的项目根目录就是<code>trunk</code>子目录了。Git 会自动地删除不对这个子目录产生影响的提交。</p>
<h4 id="全局性地更换电子邮件地址"><a href="#全局性地更换电子邮件地址" class="headerlink" title="全局性地更换电子邮件地址"></a>全局性地更换电子邮件地址</h4><p>另一个常见的案例是你在开始时忘了运行<code>git config</code>来设置你的姓名和电子邮件地址，也许你想开源一个项目，把你所有的工作电子邮件地址修改为个人地址。无论哪种情况你都可以用<code>filter-branch</code>来更换多次提交里的电子邮件地址。你必须小心一些，只改变属于你的电子邮件地址，所以你使用<code>--commit-filter</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --commit-filter &#x27;</span><br><span class="line">        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];</span><br><span class="line">        then</span><br><span class="line">                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;</span><br><span class="line">                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        else</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        fi&#x27; HEAD</span><br></pre></td></tr></table></figure>

<p>这个会遍历并重写所有提交使之拥有你的新地址。因为提交里包含了它们的父提交的SHA-1值，这个命令会修改你的历史中的所有提交，而不仅仅是包含了匹配的电子邮件地址的那些。</p>
<h2 id="使用-Git-调试"><a href="#使用-Git-调试" class="headerlink" title="使用 Git 调试"></a>使用 Git 调试</h2><p>Git 同样提供了一些工具来帮助你调试项目中遇到的问题。由于 Git 被设计为可应用于几乎任何类型的项目，这些工具是通用型，但是在遇到问题时可以经常帮助你查找缺陷所在。</p>
<h3 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h3><p>如果你在追踪代码中的缺陷想知道这是什么时候为什么被引进来的，文件标注会是你的最佳工具。它会显示文件中对每一行进行修改的最近一次提交。因此，如果你发现自己代码中的一个方法存在缺陷，你可以用<code>git blame</code>来标注文件，查看那个方法的每一行分别是由谁在哪一天修改的。下面这个例子使用了<code>-L</code>选项来限制输出范围在第12至22行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git blame -L 12,22 simplegit.rb</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = &#x27;master&#x27;)</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(&quot;git show #&#123;tree&#125;&quot;)</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = &#x27;master&#x27;)</span><br><span class="line">79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(&quot;git log #&#123;tree&#125;&quot;)</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(&quot;git blame #&#123;path&#125;&quot;)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end</span><br></pre></td></tr></table></figure>

<p>请注意第一个域里是最后一次修改该行的那次提交的 SHA-1 值。接下去的两个域是从那次提交中抽取的值——作者姓名和日期——所以你可以方便地获知谁在什么时候修改了这一行。在这后面是行号和文件的内容。请注意<code>^4832fe2</code>提交的那些行，这些指的是文件最初提交的那些行。那个提交是文件第一次被加入这个项目时存在的，自那以后未被修改过。这会带来小小的困惑，因为你已经至少看到了Git使用<code>^</code>来修饰一个提交的SHA值的三种不同的意义，但这里确实就是这个意思。</p>
<p>另一件很酷的事情是在 Git 中你不需要显式地记录文件的重命名。它会记录快照然后根据现实尝试找出隐式的重命名动作。这其中有一个很有意思的特性就是你可以让它找出所有的代码移动。如果你在<code>git blame</code>后加上<code>-C</code>，Git会分析你在标注的文件然后尝试找出其中代码片段的原始出处，如果它是从其他地方拷贝过来的话。最近，我在将一个名叫<code>GITServerHandler.m</code>的文件分解到多个文件中，其中一个是<code>GITPackUpload.m</code>。通过对<code>GITPackUpload.m</code>执行带<code>-C</code>参数的blame命令，我可以看到代码块的原始出处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git blame -C -L 141,153 GITPackUpload.m</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 141)</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 143) &#123;</span><br><span class="line">70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@&quot;GATHER COMMI</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&quot;GATHER COMMI</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) &#123;</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</span><br></pre></td></tr></table></figure>

<p>这真的非常有用。通常，你会把你拷贝代码的那次提交作为原始提交，因为这是你在这个文件中第一次接触到那几行。Git可以告诉你编写那些行的原始提交，即便是在另一个文件里。</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>标注文件在你知道问题是哪里引入的时候会有帮助。如果你不知道，并且自上次代码可用的状态已经经历了上百次的提交，你可能就要求助于<code>bisect</code>命令了。<code>bisect</code>会在你的提交历史中进行二分查找来尽快地确定哪一次提交引入了错误。</p>
<p>例如你刚刚推送了一个代码发布版本到产品环境中，对代码为什么会表现成那样百思不得其解。你回到你的代码中，还好你可以重现那个问题，但是找不到在哪里。你可以对代码执行bisect来寻找。首先你运行<code>git bisect start</code>启动，然后你用<code>git bisect bad</code>来告诉系统当前的提交已经有问题了。然后你必须告诉bisect已知的最后一次正常状态是哪次提交，使用<code>git bisect good [good_commit]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect start</span><br><span class="line">$ git bisect bad</span><br><span class="line">$ git bisect good v1.0</span><br><span class="line">Bisecting: 6 revisions left to test after this</span><br><span class="line">[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</span><br></pre></td></tr></table></figure>

<p>Git 发现在你标记为正常的提交(v1.0)和当前的错误版本之间有大约12次提交，于是它检出中间的一个。在这里，你可以运行测试来检查问题是否存在于这次提交。如果是，那么它是在这个中间提交之前的某一次引入的；如果否，那么问题是在中间提交之后引入的。假设这里是没有错误的，那么你就通过<code>git bisect good</code>来告诉 Git 然后继续你的旅程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect good</span><br><span class="line">Bisecting: 3 revisions left to test after this</span><br><span class="line">[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</span><br></pre></td></tr></table></figure>

<p>现在你在另外一个提交上了，在你刚刚测试通过的和一个错误提交的中点处。你再次运行测试然后发现这次提交是错误的，因此你通过<code>git bisect bad</code>来告诉Git：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect bad</span><br><span class="line">Bisecting: 1 revisions left to test after this</span><br><span class="line">[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</span><br></pre></td></tr></table></figure>

<p>这次提交是好的，那么 Git 就获得了确定问题引入位置所需的所有信息。它告诉你第一个错误提交的 SHA-1 值并且显示一些提交说明以及哪些文件在那次提交里修改过，这样你可以找出缺陷被引入的根源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect good</span><br><span class="line">b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit</span><br><span class="line">commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04</span><br><span class="line">Author: PJ Hyett &lt;pjhyett@example.com&gt;</span><br><span class="line">Date:   Tue Jan 27 14:48:32 2009 -0800</span><br><span class="line"></span><br><span class="line">    secure this thing</span><br><span class="line"></span><br><span class="line">:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730</span><br><span class="line">f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</span><br></pre></td></tr></table></figure>

<p>当你完成之后，你应该运行<code>git bisect reset</code>来重设你的HEAD到你开始前的地方，否则你会处于一个诡异的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect reset</span><br></pre></td></tr></table></figure>

<p>这是个强大的工具，可以帮助你检查上百的提交，在几分钟内找出缺陷引入的位置。事实上，如果你有一个脚本会在工程正常时返回0，错误时返回非0的话，你可以完全自动地执行<code>git bisect</code>。首先你需要提供已知的错误和正确提交来告诉它二分查找的范围。你可以通过<code>bisect start</code>命令来列出它们，先列出已知的错误提交再列出已知的正确提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect start HEAD v1.0</span><br><span class="line">$ git bisect run test-error.sh</span><br></pre></td></tr></table></figure>

<p>这样会自动地在每一个检出的提交里运行<code>test-error.sh</code>直到Git找出第一个破损的提交。你也可以运行像<code>make</code>或者<code>make tests</code>或者任何你所拥有的来为你执行自动化的测试。</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>经常有这样的事情，当你在一个项目上工作时，你需要在其中使用另外一个项目。也许它是一个第三方开发的库或者是你独立开发和并在多个父项目中使用的。这个场景下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。</p>
<p>这里有一个例子。假设你在开发一个网站，为之创建Atom源。你不想编写一个自己的Atom生成代码，而是决定使用一个库。你可能不得不像CPAN install或者Ruby gem一样包含来自共享库的代码，或者将代码拷贝到你的项目树中。如果采用包含库的办法，那么不管用什么办法都很难去定制这个库，部署它就更加困难了，因为你必须确保每个客户都拥有那个库。把代码包含到你自己的项目中带来的问题是，当上游被修改时，任何你进行的定制化的修改都很难归并。</p>
<p>Git 通过子模块处理这个问题。子模块允许你将一个 Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>
<h3 id="子模块初步"><a href="#子模块初步" class="headerlink" title="子模块初步"></a>子模块初步</h3><p>假设你想把 Rack 库（一个 Ruby 的 web 服务器网关接口）加入到你的项目中，可能既要保持你自己的变更，又要延续上游的变更。首先你要把外部的仓库克隆到你的子目录中。你通过<code>git submodule add</code>将外部项目加为子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add git://github.com/chneukirchen/rack.git rack</span><br><span class="line">Initialized empty Git repository in /opt/subtest/rack/.git/</span><br><span class="line">remote: Counting objects: 3181, done.</span><br><span class="line">remote: Compressing objects: 100% (1534/1534), done.</span><br><span class="line">remote: Total 3181 (delta 1951), reused 2623 (delta 1603)</span><br><span class="line">Receiving objects: 100% (3181/3181), 675.42 KiB | 422 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1951/1951), done.</span><br></pre></td></tr></table></figure>

<p>现在你就在项目里的<code>rack</code>子目录下有了一个 Rack 项目。你可以进入那个子目录，进行变更，加入你自己的远程可写仓库来推送你的变更，从原始仓库拉取和归并等等。如果你在加入子模块后立刻运行<code>git status</code>，你会看到下面两项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#      new file:   .gitmodules</span><br><span class="line">#      new file:   rack</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>首先你注意到有一个<code>.gitmodules</code>文件。这是一个配置文件，保存了项目 URL 和你拉取到的本地子目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitmodules</span><br><span class="line">[submodule &quot;rack&quot;]</span><br><span class="line">      path = rack</span><br><span class="line">      url = git://github.com/chneukirchen/rack.git</span><br></pre></td></tr></table></figure>

<p>如果你有多个子模块，这个文件里会有多个条目。很重要的一点是这个文件跟其他文件一样也是处于版本控制之下的，就像你的<code>.gitignore</code>文件一样。它跟项目里的其他文件一样可以被推送和拉取。这是其他克隆此项目的人获知子模块项目来源的途径。</p>
<p><code>git status</code>的输出里所列的另一项目是 rack 。如果你运行在那上面运行<code>git diff</code>，会发现一些有趣的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached rack</span><br><span class="line">diff --git a/rack b/rack</span><br><span class="line">new file mode 160000</span><br><span class="line">index 0000000..08d709f</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/rack</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</span><br></pre></td></tr></table></figure>

<p>尽管<code>rack</code>是你工作目录里的子目录，但 Git 把它视作一个子模块，当你不在那个目录里时并不记录它的内容。取而代之的是，Git 将它记录成来自那个仓库的一个特殊的提交。当你在那个子目录里修改并提交时，子项目会通知那里的 HEAD 已经发生变更并记录你当前正在工作的那个提交；通过那样的方法，当其他人克隆此项目，他们可以重新创建一致的环境。</p>
<p>这是关于子模块的重要一点：你记录他们当前确切所处的提交。你不能记录一个子模块的<code>master</code>或者其他的符号引用。</p>
<p>当你提交时，会看到类似下面的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#x27;first commit with submodule rack&#x27;</span><br><span class="line">[master 0550271] first commit with submodule rack</span><br><span class="line"> 2 files changed, 4 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 rack</span><br></pre></td></tr></table></figure>

<p>注意 rack 条目的 160000 模式。这在Git中是一个特殊模式，基本意思是你将一个提交记录为一个目录项而不是子目录或者文件。</p>
<p>你可以将<code>rack</code>目录当作一个独立的项目，保持一个指向子目录的最新提交的指针然后反复地更新上层项目。所有的Git命令都在两个子目录里独立工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log -1</span><br><span class="line">commit 0550271328a0038865aad6331e620cd7238601bb</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Apr 9 09:03:56 2009 -0700</span><br><span class="line"></span><br><span class="line">    first commit with submodule rack</span><br><span class="line">$ cd rack/</span><br><span class="line">$ git log -1</span><br><span class="line">commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</span><br><span class="line">Author: Christian Neukirchen &lt;chneukirchen@gmail.com&gt;</span><br><span class="line">Date:   Wed Mar 25 14:49:04 2009 +0100</span><br><span class="line"></span><br><span class="line">    Document version change</span><br></pre></td></tr></table></figure>

<h3 id="克隆一个带子模块的项目"><a href="#克隆一个带子模块的项目" class="headerlink" title="克隆一个带子模块的项目"></a>克隆一个带子模块的项目</h3><p>这里你将克隆一个带子模块的项目。当你接收到这样一个项目，你将得到了包含子项目的目录，但里面没有文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/myproject.git</span><br><span class="line">Initialized empty Git repository in /opt/myproject/.git/</span><br><span class="line">remote: Counting objects: 6, done.</span><br><span class="line">remote: Compressing objects: 100% (4/4), done.</span><br><span class="line">remote: Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (6/6), done.</span><br><span class="line">$ cd myproject</span><br><span class="line">$ ls -l</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 schacon  admin   3 Apr  9 09:11 README</span><br><span class="line">drwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack</span><br><span class="line">$ ls rack/</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p><code>rack</code>目录存在了，但是是空的。你必须运行两个命令：<code>git submodule init</code>来初始化你的本地配置文件，<code>git submodule update</code>来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">Submodule &#x27;rack&#x27; (git://github.com/chneukirchen/rack.git) registered for path &#x27;rack&#x27;</span><br><span class="line">$ git submodule update</span><br><span class="line">Initialized empty Git repository in /opt/myproject/rack/.git/</span><br><span class="line">remote: Counting objects: 3181, done.</span><br><span class="line">remote: Compressing objects: 100% (1534/1534), done.</span><br><span class="line">remote: Total 3181 (delta 1951), reused 2623 (delta 1603)</span><br><span class="line">Receiving objects: 100% (3181/3181), 675.42 KiB | 173 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1951/1951), done.</span><br><span class="line">Submodule path &#x27;rack&#x27;: checked out &#x27;08d709f78b8c5b0fbeb7821e37fa53e69afcf433&#x27;</span><br></pre></td></tr></table></figure>

<p>现在你的<code>rack</code>子目录就处于你先前提交的确切状态了。如果另外一个开发者变更了 rack 的代码并提交，你拉取那个引用然后归并之，将得到稍有点怪异的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line">Updating 0550271..85a3eee</span><br><span class="line">Fast forward</span><br><span class="line"> rack |    2 +-</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line">[master*]$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#      modified:   rack</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>你归并来的仅仅上是一个指向你的子模块的指针；但是它并不更新你子模块目录里的代码，所以看起来你的工作目录处于一个临时状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/rack b/rack</span><br><span class="line">index 6c5e70b..08d709f 160000</span><br><span class="line">--- a/rack</span><br><span class="line">+++ b/rack</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0</span><br><span class="line">+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</span><br></pre></td></tr></table></figure>

<p>事情就是这样，因为你所拥有的指向子模块的指针和子模块目录的真实状态并不匹配。为了修复这一点，你必须再次运行<code>git submodule update</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 2 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From git@github.com:schacon/rack</span><br><span class="line">   08d709f..6c5e70b  master     -&gt; origin/master</span><br><span class="line">Submodule path &#x27;rack&#x27;: checked out &#x27;6c5e70b984a60b3cecd395edd5b48a7575bf58e0&#x27;</span><br></pre></td></tr></table></figure>

<p>每次你从主项目中拉取一个子模块的变更都必须这样做。看起来很怪但是管用。</p>
<p>一个常见问题是当开发者对子模块做了一个本地的变更但是并没有推送到公共服务器。然后他们提交了一个指向那个非公开状态的指针然后推送上层项目。当其他开发者试图运行<code>git submodule update</code>，那个子模块系统会找不到所引用的提交，因为它只存在于第一个开发者的系统中。如果发生那种情况，你会看到类似这样的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update</span><br><span class="line">fatal: reference isn’t a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0</span><br><span class="line">Unable to checkout &#x27;6c5e70b984a60b3cecd395edd5ba7575bf58e0&#x27; in submodule path &#x27;rack&#x27;</span><br></pre></td></tr></table></figure>

<p>你不得不去查看谁最后变更了子模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log -1 rack</span><br><span class="line">commit 85a3eee996800fcfa91e2119372dd4172bf76678</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Apr 9 09:19:14 2009 -0700</span><br><span class="line"></span><br><span class="line">    added a submodule reference I will never make public. hahahahaha!</span><br></pre></td></tr></table></figure>

<p>然后，你给那个家伙发电子邮件说他一通。</p>
<h3 id="上层项目"><a href="#上层项目" class="headerlink" title="上层项目"></a>上层项目</h3><p>有时候，开发者想按照他们的分组获取一个大项目的子目录的子集。如果你是从 CVS 或者 Subversion 迁移过来的话这个很常见，在那些系统中你已经定义了一个模块或者子目录的集合，而你想延续这种类型的工作流程。</p>
<p>在 Git 中实现这个的一个好办法是你将每一个子目录都做成独立的 Git 仓库，然后创建一个上层项目的 Git 仓库包含多个子模块。这个办法的一个优势是你可以在上层项目中通过标签和分支更为明确地定义项目之间的关系。</p>
<h3 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h3><p>使用子模块并非没有任何缺点。首先，你在子模块目录中工作时必须相对小心。当你运行<code>git submodule update</code>，它会检出项目的指定版本，但是不在分支内。这叫做获得一个分离的头——这意味着 HEAD 文件直接指向一次提交，而不是一个符号引用。问题在于你通常并不想在一个分离的头的环境下工作，因为太容易丢失变更了。如果你先执行了一次<code>submodule update</code>，然后在那个子模块目录里不创建分支就进行提交，然后再次从上层项目里运行<code>git submodule update</code>同时不进行提交，Git会毫无提示地覆盖你的变更。技术上讲你不会丢失工作，但是你将失去指向它的分支，因此会很难取到。</p>
<p>为了避免这个问题，当你在子模块目录里工作时应使用<code>git checkout -b work</code>创建一个分支。当你再次在子模块里更新的时候，它仍然会覆盖你的工作，但是至少你拥有一个可以回溯的指针。</p>
<p>切换带有子模块的分支同样也很有技巧。如果你创建一个新的分支，增加了一个子模块，然后切换回不带该子模块的分支，你仍然会拥有一个未被追踪的子模块的目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b rack</span><br><span class="line">Switched to a new branch &quot;rack&quot;</span><br><span class="line">$ git submodule add git@github.com:schacon/rack.git rack</span><br><span class="line">Initialized empty Git repository in /opt/myproj/rack/.git/</span><br><span class="line">...</span><br><span class="line">Receiving objects: 100% (3184/3184), 677.42 KiB | 34 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1952/1952), done.</span><br><span class="line">$ git commit -am &#x27;added rack submodule&#x27;</span><br><span class="line">[rack cc49a69] added rack submodule</span><br><span class="line"> 2 files changed, 4 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 rack</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &quot;master&quot;</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Untracked files:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">#</span><br><span class="line">#      rack/</span><br></pre></td></tr></table></figure>

<p>你将不得不将它移走或者删除，这样的话当你切换回去的时候必须重新克隆它——你可能会丢失你未推送的本地的变更或分支。</p>
<p>最后一个需要引起注意的是关于从子目录切换到子模块的。如果你已经跟踪了你项目中的一些文件但是想把它们移到子模块去，你必须非常小心，否则Git会生你的气。假设你的项目中有一个子目录里放了 rack 的文件，然后你想将它转换为子模块。如果你删除子目录然后运行<code>submodule add</code>，Git会向你大吼：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm -Rf rack/</span><br><span class="line">$ git submodule add git@github.com:schacon/rack.git rack</span><br><span class="line">&#x27;rack&#x27; already exists in the index</span><br></pre></td></tr></table></figure>

<p>你必须先将<code>rack</code>目录撤回。然后你才能加入子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r rack</span><br><span class="line">$ git submodule add git@github.com:schacon/rack.git rack</span><br><span class="line">Initialized empty Git repository in /opt/testsub/rack/.git/</span><br><span class="line">remote: Counting objects: 3184, done.</span><br><span class="line">remote: Compressing objects: 100% (1465/1465), done.</span><br><span class="line">remote: Total 3184 (delta 1952), reused 2770 (delta 1675)</span><br><span class="line">Receiving objects: 100% (3184/3184), 677.42 KiB | 88 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1952/1952), done.</span><br></pre></td></tr></table></figure>

<p>现在假设你在一个分支里那样做了。如果你尝试切换回一个仍然在目录里保留那些文件而不是子模块的分支时——你会得到下面的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">error: Untracked working tree file &#x27;rack/AUTHORS&#x27; would be overwritten by merge.</span><br></pre></td></tr></table></figure>

<p>你必须先移除<code>rack</code>子模块的目录才能切换到不包含它的分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mv rack /tmp/</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &quot;master&quot;</span><br><span class="line">$ ls</span><br><span class="line">README	rack</span><br></pre></td></tr></table></figure>

<p>然后，当你切换回来，你会得到一个空的<code>rack</code>目录。你可以运行<code>git submodule update</code>重新克隆，也可以将<code>/tmp/rack</code>目录重新移回空目录。</p>
<h2 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h2><p>现在你已经看到了子模块系统的麻烦之处，让我们来看一下解决相同问题的另一途径。当 Git 归并时，它会检查需要归并的内容然后选择一个合适的归并策略。如果你归并的分支是两个，Git使用一个<em>递归</em>策略。如果你归并的分支超过两个，Git采用<em>章鱼</em>策略。这些策略是自动选择的，因为递归策略可以处理复杂的三路归并情况——比如多于一个共同祖先的——但是它只能处理两个分支的归并。章鱼归并可以处理多个分支但是但必须更加小心以避免冲突带来的麻烦，因此它被选中作为归并两个以上分支的默认策略。</p>
<p>实际上，你也可以选择其他策略。其中的一个就是<em>子树</em>归并，你可以用它来处理子项目问题。这里你会看到如何换用子树归并的方法来实现前一节里所做的 rack 的嵌入。</p>
<p>子树归并的思想是你拥有两个工程，其中一个项目映射到另外一个项目的子目录中，反过来也一样。当你指定一个子树归并，Git可以聪明地探知其中一个是另外一个的子树从而实现正确的归并——这相当神奇。</p>
<p>首先你将 Rack 应用加入到项目中。你将 Rack 项目当作你项目中的一个远程引用，然后将它检出到它自身的分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add rack_remote git@github.com:schacon/rack.git</span><br><span class="line">$ git fetch rack_remote</span><br><span class="line">warning: no common commits</span><br><span class="line">remote: Counting objects: 3184, done.</span><br><span class="line">remote: Compressing objects: 100% (1465/1465), done.</span><br><span class="line">remote: Total 3184 (delta 1952), reused 2770 (delta 1675)</span><br><span class="line">Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1952/1952), done.</span><br><span class="line">From git@github.com:schacon/rack</span><br><span class="line"> * [new branch]      build      -&gt; rack_remote/build</span><br><span class="line"> * [new branch]      master     -&gt; rack_remote/master</span><br><span class="line"> * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4</span><br><span class="line"> * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9</span><br><span class="line">$ git checkout -b rack_branch rack_remote/master</span><br><span class="line">Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.</span><br><span class="line">Switched to a new branch &quot;rack_branch&quot;</span><br></pre></td></tr></table></figure>

<p>现在在你的<code>rack_branch</code>分支中就有了Rack项目的根目录，而你自己的项目在<code>master</code>分支中。如果你先检出其中一个然后另外一个，你会看到它们有不同的项目根目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">AUTHORS	       KNOWN-ISSUES   Rakefile      contrib	       lib</span><br><span class="line">COPYING	       README         bin           example	       test</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &quot;master&quot;</span><br><span class="line">$ ls</span><br><span class="line">README</span><br></pre></td></tr></table></figure>

<p>要将 Rack 项目当作子目录拉取到你的<code>master</code>项目中。你可以在 Git 中用<code>git read-tree</code>来实现。你会在第9章学到更多与<code>read-tree</code>和它的朋友相关的东西，当前你会知道它读取一个分支的根目录树到当前的暂存区和工作目录。你只要切换回你的<code>master</code>分支，然后拉取<code>rack_branch</code>到你主项目的<code>master</code>分支的<code>rack</code>子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=rack/ -u rack_branch</span><br></pre></td></tr></table></figure>

<p>当你提交的时候，看起来就像你在那个子目录下拥有Rack的文件——就像你从一个tarball里拷贝的一样。有意思的是你可以比较容易地归并其中一个分支的变更到另外一个。因此，如果 Rack 项目更新了，你可以通过切换到那个分支并执行拉取来获得上游的变更：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout rack_branch</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p>然后，你可以将那些变更归并回你的 master 分支。你可以使用<code>git merge -s subtree</code>，它会工作的很好；但是 Git 同时会把历史归并到一起，这可能不是你想要的。为了拉取变更并预置提交说明，需要在<code>-s subtree</code>策略选项的同时使用<code>--squash</code>和<code>--no-commit</code>选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --squash -s subtree --no-commit rack_branch</span><br><span class="line">Squash commit -- not updating HEAD</span><br><span class="line">Automatic merge went well; stopped before committing as requested</span><br></pre></td></tr></table></figure>

<p>所有 Rack 项目的变更都被归并并且可以进行本地提交。你也可以做相反的事情——在你主分支的<code>rack</code>目录里进行变更然后归并回<code>rack_branch</code>分支，然后将它们提交给维护者或者推送到上游。</p>
<p>为了得到<code>rack</code>子目录和你<code>rack_branch</code>分支的区别——以决定你是否需要归并它们——你不能使用一般的<code>diff</code>命令。而是对你想比较的分支运行<code>git diff-tree</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff-tree -p rack_branch</span><br></pre></td></tr></table></figure>

<p>或者，为了比较你的<code>rack</code>子目录和服务器上你拉取时的<code>master</code>分支，你可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff-tree -p rack_remote/master</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/git/" rel="tag"># git</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/22/git/git-%E5%88%86%E5%B8%83%E5%BC%8Fgit/" rel="prev" title="git-分布式git">
      <i class="fa fa-chevron-left"></i> git-分布式git
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/23/git/git-git%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F/" rel="next" title="git-git与其他系统">
      git-git与其他系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC%EF%BC%88Revision%EF%BC%89%E9%80%89%E6%8B%A9"><span class="nav-number">1.</span> <span class="nav-text">修订版本（Revision）选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC"><span class="nav-number">1.1.</span> <span class="nav-text">单个修订版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E7%9F%AD%E7%9A%84SHA"><span class="nav-number">1.2.</span> <span class="nav-text">简短的SHA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-SHA-1-%E7%9A%84%E7%AE%80%E7%9F%AD%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.</span> <span class="nav-text">关于 SHA-1 的简短说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%BC%95%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">分支引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%97%A5%E5%BF%97%E9%87%8C%E7%9A%84%E7%AE%80%E7%A7%B0"><span class="nav-number">1.5.</span> <span class="nav-text">引用日志里的简称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%96%E5%85%88%E5%BC%95%E7%94%A8"><span class="nav-number">1.6.</span> <span class="nav-text">祖先引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E8%8C%83%E5%9B%B4"><span class="nav-number">1.7.</span> <span class="nav-text">提交范围</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E7%82%B9"><span class="nav-number">1.7.1.</span> <span class="nav-text">双点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%82%B9"><span class="nav-number">1.7.2.</span> <span class="nav-text">多点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%82%B9"><span class="nav-number">1.7.3.</span> <span class="nav-text">三点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98"><span class="nav-number">2.</span> <span class="nav-text">交互式暂存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%82%E5%AD%98%E5%92%8C%E6%92%A4%E5%9B%9E%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">暂存和撤回文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%82%E5%AD%98%E8%A1%A5%E4%B8%81"><span class="nav-number">2.2.</span> <span class="nav-text">暂存补丁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">储藏（Stashing）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%82%A8%E8%97%8F%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">储藏你的工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E5%82%A8%E8%97%8F-Un-applying-a-Stash"><span class="nav-number">3.2.</span> <span class="nav-text">取消储藏(Un-applying a Stash)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%82%A8%E8%97%8F%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"><span class="nav-number">3.3.</span> <span class="nav-text">从储藏中创建分支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2"><span class="nav-number">4.</span> <span class="nav-text">重写历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="nav-number">4.1.</span> <span class="nav-text">改变最近一次提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4%E8%AF%B4%E6%98%8E"><span class="nav-number">4.2.</span> <span class="nav-text">修改多个提交说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E6%8F%90%E4%BA%A4"><span class="nav-number">4.3.</span> <span class="nav-text">重排提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E5%88%B6-Squashing-%E6%8F%90%E4%BA%A4"><span class="nav-number">4.4.</span> <span class="nav-text">压制(Squashing)提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E6%8F%90%E4%BA%A4"><span class="nav-number">4.5.</span> <span class="nav-text">拆分提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BC%B9%E7%BA%A7%E9%80%89%E9%A1%B9-filter-branch"><span class="nav-number">4.6.</span> <span class="nav-text">核弹级选项: filter-branch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%89%80%E6%9C%89%E6%8F%90%E4%BA%A4%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">4.6.1.</span> <span class="nav-text">从所有提交中删除一个文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AD%90%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%96%B0%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="nav-number">4.6.2.</span> <span class="nav-text">将一个子目录设置为新的根目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%80%A7%E5%9C%B0%E6%9B%B4%E6%8D%A2%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80"><span class="nav-number">4.6.3.</span> <span class="nav-text">全局性地更换电子邮件地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Git-%E8%B0%83%E8%AF%95"><span class="nav-number">5.</span> <span class="nav-text">使用 Git 调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A0%87%E6%B3%A8"><span class="nav-number">5.1.</span> <span class="nav-text">文件标注</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">5.2.</span> <span class="nav-text">二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E6%A8%A1%E5%9D%97"><span class="nav-number">6.</span> <span class="nav-text">子模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%A8%A1%E5%9D%97%E5%88%9D%E6%AD%A5"><span class="nav-number">6.1.</span> <span class="nav-text">子模块初步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%8B%E9%9A%86%E4%B8%80%E4%B8%AA%E5%B8%A6%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E9%A1%B9%E7%9B%AE"><span class="nav-number">6.2.</span> <span class="nav-text">克隆一个带子模块的项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E9%A1%B9%E7%9B%AE"><span class="nav-number">6.3.</span> <span class="nav-text">上层项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.</span> <span class="nav-text">子模块的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E6%A0%91%E5%90%88%E5%B9%B6"><span class="nav-number">7.</span> <span class="nav-text">子树合并</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CHENPENGBLOG"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">CHENPENGBLOG</p>
  <div class="site-description" itemprop="description">记录！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/yourname" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CHENPENGBLOG</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
